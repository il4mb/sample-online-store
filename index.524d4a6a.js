let e,t,n,r;function l(e,t,n,r){Object.defineProperty(e,t,{get:n,set:r,enumerable:!0,configurable:!0})}var o,i,s,a,u,c,p="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{},f={},d={},h=p.parcelRequire995f;null==h&&((h=function(e){if(e in f)return f[e].exports;if(e in d){var t=d[e];delete d[e];var n={id:e,exports:{}};return f[e]=n,t.call(n.exports,n,n.exports),n.exports}var r=Error("Cannot find module '"+e+"'");throw r.code="MODULE_NOT_FOUND",r}).register=function(e,t){d[e]=t},p.parcelRequire995f=h),h.register("ecd4d",function(e,t){l(e.exports,"computed",()=>h("TusQn").computed),l(e.exports,"createCommentVNode",()=>h("TusQn").createCommentVNode),l(e.exports,"createElementBlock",()=>h("TusQn").createElementBlock),l(e.exports,"createElementVNode",()=>h("TusQn").createElementVNode),l(e.exports,"createTextVNode",()=>h("TusQn").createTextVNode),l(e.exports,"createVNode",()=>h("TusQn").createVNode),l(e.exports,"defineComponent",()=>h("TusQn").defineComponent),l(e.exports,"Fragment",()=>h("TusQn").Fragment),l(e.exports,"getCurrentInstance",()=>h("TusQn").getCurrentInstance),l(e.exports,"h",()=>h("TusQn").h),l(e.exports,"initCustomFormatter",()=>h("TusQn").initCustomFormatter),l(e.exports,"inject",()=>h("TusQn").inject),l(e.exports,"nextTick",()=>h("TusQn").nextTick),l(e.exports,"normalizeClass",()=>h("8POXm").normalizeClass),l(e.exports,"onActivated",()=>h("TusQn").onActivated),l(e.exports,"onDeactivated",()=>h("TusQn").onDeactivated),l(e.exports,"onUnmounted",()=>h("TusQn").onUnmounted),l(e.exports,"openBlock",()=>h("TusQn").openBlock),l(e.exports,"provide",()=>h("TusQn").provide),l(e.exports,"reactive",()=>h("01W3b").reactive),l(e.exports,"ref",()=>h("01W3b").ref),l(e.exports,"renderList",()=>h("TusQn").renderList),l(e.exports,"resolveComponent",()=>h("TusQn").resolveComponent),l(e.exports,"shallowReactive",()=>h("01W3b").shallowReactive),l(e.exports,"watch",()=>h("TusQn").watch),l(e.exports,"watchEffect",()=>h("TusQn").watchEffect),l(e.exports,"withCtx",()=>h("TusQn").withCtx),l(e.exports,"createApp",()=>h("eeJ70").createApp),l(e.exports,"shallowRef",()=>h("01W3b").shallowRef),l(e.exports,"unref",()=>h("01W3b").unref),l(e.exports,"toDisplayString",()=>h("8POXm").toDisplayString),h("TusQn"),h("eeJ70"),h("01W3b"),h("8POXm")}),h.register("TusQn",function(e,t){let n,r,o,i,s;l(e.exports,"warn",()=>c),l(e.exports,"callWithAsyncErrorHandling",()=>f),l(e.exports,"nextTick",()=>E),l(e.exports,"Fragment",()=>t_),l(e.exports,"Static",()=>tb),l(e.exports,"withCtx",()=>H),l(e.exports,"createVNode",()=>tN),l(e.exports,"openBlock",()=>tT),l(e.exports,"watchEffect",()=>X),l(e.exports,"watchPostEffect",()=>Z),l(e.exports,"watch",()=>et),l(e.exports,"useTransitionState",()=>es),l(e.exports,"onMounted",()=>eC),l(e.exports,"BaseTransitionPropsValidators",()=>eu),l(e.exports,"getCurrentInstance",()=>tH),l(e.exports,"getTransitionRawChildren",()=>eg),l(e.exports,"resolveTransitionHooks",()=>ef),l(e.exports,"setTransitionHooks",()=>em),l(e.exports,"BaseTransition",()=>ec),l(e.exports,"defineComponent",()=>ev),l(e.exports,"onUpdated",()=>ek),l(e.exports,"onActivated",()=>ex),l(e.exports,"onDeactivated",()=>eb),l(e.exports,"onUnmounted",()=>eR),l(e.exports,"resolveComponent",()=>eM),l(e.exports,"renderList",()=>eB),l(e.exports,"computed",()=>t1),l(e.exports,"provide",()=>e3),l(e.exports,"inject",()=>e4),l(e.exports,"createTextVNode",()=>tM),l(e.exports,"createRenderer",()=>td),l(e.exports,"createHydrationRenderer",()=>th),l(e.exports,"createElementBlock",()=>tS),l(e.exports,"createElementVNode",()=>tF),l(e.exports,"createCommentVNode",()=>tj),l(e.exports,"isRuntimeOnly",()=>tX),l(e.exports,"h",()=>t2),l(e.exports,"initCustomFormatter",()=>t4),l(e.exports,"reactive",()=>h("01W3b").reactive),l(e.exports,"ref",()=>h("01W3b").ref),l(e.exports,"shallowReactive",()=>h("01W3b").shallowReactive),l(e.exports,"toRaw",()=>h("01W3b").toRaw),l(e.exports,"camelize",()=>h("8POXm").camelize),l(e.exports,"normalizeClass",()=>h("8POXm").normalizeClass);var a=h("01W3b"),u=h("8POXm");function c(e,...t){}function p(e,t,n,r){let l;try{l=r?e(...r):e()}catch(e){d(e,t,n)}return l}function f(e,t,n,r){if((0,u.isFunction)(e)){let l=p(e,t,n,r);return l&&(0,u.isPromise)(l)&&l.catch(e=>{d(e,t,n)}),l}let l=[];for(let o=0;o<e.length;o++)l.push(f(e[o],t,n,r));return l}function d(e,t,n,r=!0){if(t&&t.vnode,t){let r=t.parent,l=t.proxy;for(;r;){let t=r.ec;if(t){for(let r=0;r<t.length;r++)if(!1===t[r](e,l,n))return}r=r.parent}let o=t.appContext.config.errorHandler;if(o){p(o,null,10,[e,l,n]);return}}(function(e,t,n,r=!0){console.error(e)})(e,0,0,r)}let m=!1,g=!1,_=[],y=0,x=[],b=null,O=0,w=/* @__PURE__ */Promise.resolve(),T=null;function E(e){let t=T||w;return e?t.then(this?e.bind(this):e):t}function C(e){_.length&&_.includes(e,m&&e.allowRecurse?y+1:y)||(null==e.id?_.push(e):_.splice(function(e){let t=y+1,n=_.length;for(;t<n;){let r=t+n>>>1,l=R(_[r]);l<e?t=r+1:n=r}return t}(e.id),0,e),S())}function S(){m||g||(g=!0,T=w.then(function e(t){g=!1,m=!0,_.sort(A),u.NOOP;try{for(y=0;y<_.length;y++){let e=_[y];e&&!1!==e.active&&p(e,null,14)}}finally{y=0,_.length=0,P(t),m=!1,T=null,(_.length||x.length)&&e(t)}}))}function k(e,t=m?y+1:0){for(;t<_.length;t++){let e=_[t];e&&e.pre&&(_.splice(t,1),t--,e())}}function P(e){if(x.length){let e=[...new Set(x)];if(x.length=0,b){b.push(...e);return}for((b=e).sort((e,t)=>R(e)-R(t)),O=0;O<b.length;O++)b[O]();b=null,O=0}}let R=e=>null==e.id?1/0:e.id,A=(e,t)=>{let n=R(e)-R(t);if(0===n){if(e.pre&&!t.pre)return -1;if(t.pre&&!e.pre)return 1}return n},V=[],F=!1;function N(e,...t){n?n.emit(e,...t):F||V.push({event:e,args:t})}let L=/* @__PURE__ */B("component:added"/* COMPONENT_ADDED */),M=/* @__PURE__ */B("component:updated"/* COMPONENT_UPDATED */),j=/* @__PURE__ */B("component:removed"/* COMPONENT_REMOVED */),I=e=>{n&&"function"==typeof n.cleanupBuffer&&// remove the component if it wasn't buffered
!n.cleanupBuffer(e)&&j(e)};function B(e){return t=>{N(e,t.appContext.app,t.uid,t.parent?t.parent.uid:void 0,t)}}function D(e,t,...n){let r;if(e.isUnmounted)return;let l=e.vnode.props||u.EMPTY_OBJ,o=n,i=t.startsWith("update:"),s=i&&t.slice(7);if(s&&s in l){let e=`${"modelValue"===s?"model":s}Modifiers`,{number:t,trim:r}=l[e]||u.EMPTY_OBJ;r&&(o=n.map(e=>(0,u.isString)(e)?e.trim():e)),t&&(o=n.map(u.looseToNumber))}if(__VUE_PROD_DEVTOOLS__){var a;a=o,N("component:emit"/* COMPONENT_EMIT */,e.appContext.app,e,t,a)}let c=l[r=(0,u.toHandlerKey)(t)]||// also try camelCase event handler (#2249)
l[r=(0,u.toHandlerKey)((0,u.camelize)(t))];!c&&i&&(c=l[r=(0,u.toHandlerKey)((0,u.hyphenate)(t))]),c&&f(c,e,6,o);let p=l[r+"Once"];if(p){if(e.emitted){if(e.emitted[r])return}else e.emitted={};e.emitted[r]=!0,f(p,e,6,o)}}function U(e,t){return!!(e&&(0,u.isOn)(t))&&(t=t.slice(2).replace(/Once$/,""),(0,u.hasOwn)(e,t[0].toLowerCase()+t.slice(1))||(0,u.hasOwn)(e,(0,u.hyphenate)(t))||(0,u.hasOwn)(e,t))}let $=null,Q=null;function W(e){let t=$;return $=e,Q=e&&e.type.__scopeId||null,t}function H(e,t=$,n){if(!t||e._n)return e;let r=(...n)=>{let l;r._d&&(tE+=-1);let o=W(t);try{l=e(...n)}finally{W(o),r._d&&(tE+=1)}return __VUE_PROD_DEVTOOLS__&&M(t),l};return r._n=!0,r._c=!0,r._d=!0,r}function z(e){let t,n;let{type:r,vnode:l,proxy:o,withProxy:i,props:s,propsOptions:[a],slots:c,attrs:p,emit:f,render:h,renderCache:m,data:g,setupState:_,ctx:y,inheritAttrs:x}=e,b=W(e);try{if(4&l.shapeFlag){let e=i||o;t=tI(h.call(e,e,m,s,_,g,y)),n=p}else t=tI(r.length>1?r(s,{attrs:p,slots:c,emit:f}):r(s,null)),n=r.props?p:Y(p)}catch(n){tO.length=0,d(n,e,1),t=tN(tx)}let O=t;if(n&&!1!==x){let e=Object.keys(n),{shapeFlag:t}=O;e.length&&7&t&&(a&&e.some(u.isModelListener)&&(n=J(n,a)),O=tL(O,n))}return l.dirs&&((O=tL(O)).dirs=O.dirs?O.dirs.concat(l.dirs):l.dirs),l.transition&&(O.transition=l.transition),t=O,W(b),t}let Y=e=>{let t;for(let n in e)("class"===n||"style"===n||(0,u.isOn)(n))&&((t||(t={}))[n]=e[n]);return t},J=(e,t)=>{let n={};for(let r in e)(0,u.isModelListener)(r)&&r.slice(9) in t||(n[r]=e[r]);return n};function G(e,t,n){let r=Object.keys(t);if(r.length!==Object.keys(e).length)return!0;for(let l=0;l<r.length;l++){let o=r[l];if(t[o]!==e[o]&&!U(n,o))return!0}return!1}let q=e=>e.__isSuspense;function K(e,t){t&&t.pendingBranch?(0,u.isArray)(e)?t.effects.push(...e):t.effects.push(e):((0,u.isArray)(e)?x.push(...e):b&&b.includes(e,e.allowRecurse?O+1:O)||x.push(e),S())}function X(e,t){return en(e,null,t)}function Z(e,t){return en(e,null,{flush:"post"})}let ee={};function et(e,t,n){return en(e,t,n)}function en(e,t,{immediate:n,deep:r,flush:l,onTrack:o,onTrigger:i}=u.EMPTY_OBJ){var s;let c,d,h,m;let g=(0,a.getCurrentScope)()===(null==(s=tW)?void 0:s.scope)?tW:null,_=!1,y=!1;if((0,a.isRef)(e)?(c=()=>e.value,_=(0,a.isShallow)(e)):(0,a.isReactive)(e)?(c=()=>e,r=!0):(0,u.isArray)(e)?(y=!0,_=e.some(e=>(0,a.isReactive)(e)||(0,a.isShallow)(e)),c=()=>e.map(e=>(0,a.isRef)(e)?e.value:(0,a.isReactive)(e)?eo(e):(0,u.isFunction)(e)?p(e,g,2):void 0)):c=(0,u.isFunction)(e)?t?()=>p(e,g,2):()=>{if(!g||!g.isUnmounted)return d&&d(),f(e,g,3,[x])}:u.NOOP,t&&r){let e=c;c=()=>eo(e())}let x=e=>{d=w.onStop=()=>{p(e,g,4)}};if(tq){if(x=u.NOOP,t?n&&f(t,g,3,[c(),y?[]:void 0,x]):c(),"sync"!==l)return u.NOOP;{let e=t3();h=e.__watcherHandles||(e.__watcherHandles=[])}}let b=y?Array(e.length).fill(ee):ee,O=()=>{if(w.active){if(t){let e=w.run();(r||_||(y?e.some((e,t)=>(0,u.hasChanged)(e,b[t])):(0,u.hasChanged)(e,b)))&&(d&&d(),f(t,g,3,[e,// pass undefined as the old value when it's changed for the first time
b===ee?void 0:y&&b[0]===ee?[]:b,x]),b=e)}else w.run()}};O.allowRecurse=!!t,"sync"===l?m=O:"post"===l?m=()=>tf(O,g&&g.suspense):(O.pre=!0,g&&(O.id=g.uid),m=()=>C(O));let w=new a.ReactiveEffect(c,m);t?n?O():b=w.run():"post"===l?tf(w.run.bind(w),g&&g.suspense):w.run();let T=()=>{w.stop(),g&&g.scope&&(0,u.remove)(g.scope.effects,w)};return h&&h.push(T),T}function er(e,t,n){let r;let l=this.proxy,o=(0,u.isString)(e)?e.includes(".")?el(l,e):()=>l[e]:e.bind(l,l);(0,u.isFunction)(t)?r=t:(r=t.handler,n=t);let i=tW;tY(this);let s=en(o,r.bind(l),n);return i?tY(i):tJ(),s}function el(e,t){let n=t.split(".");return()=>{let t=e;for(let e=0;e<n.length&&t;e++)t=t[n[e]];return t}}function eo(e,t){if(!(0,u.isObject)(e)||e.__v_skip||(t=t||/* @__PURE__ */new Set).has(e))return e;if(t.add(e),(0,a.isRef)(e))eo(e.value,t);else if((0,u.isArray)(e))for(let n=0;n<e.length;n++)eo(e[n],t);else if((0,u.isSet)(e)||(0,u.isMap)(e))e.forEach(e=>{eo(e,t)});else if((0,u.isPlainObject)(e))for(let n in e)eo(e[n],t);return e}function ei(e,t,n,r){let l=e.dirs,o=t&&t.dirs;for(let i=0;i<l.length;i++){let s=l[i];o&&(s.oldValue=o[i].value);let u=s.dir[r];u&&((0,a.pauseTracking)(),f(u,n,8,[e.el,s,e,t]),(0,a.resetTracking)())}}function es(){let e={isMounted:!1,isLeaving:!1,isUnmounting:!1,leavingVNodes:/* @__PURE__ */new Map};return eC(()=>{e.isMounted=!0}),eP(()=>{e.isUnmounting=!0}),e}let ea=[Function,Array],eu={mode:String,appear:Boolean,persisted:Boolean,// enter
onBeforeEnter:ea,onEnter:ea,onAfterEnter:ea,onEnterCancelled:ea,// leave
onBeforeLeave:ea,onLeave:ea,onAfterLeave:ea,onLeaveCancelled:ea,// appear
onBeforeAppear:ea,onAppear:ea,onAfterAppear:ea,onAppearCancelled:ea},ec={name:"BaseTransition",props:eu,setup(e,{slots:t}){let n;let r=tH(),l=es();return()=>{let o=t.default&&eg(t.default(),!0);if(!o||!o.length)return;let i=o[0];if(o.length>1){for(let e of o)if(e.type!==tx){i=e;break}}let s=(0,a.toRaw)(e),{mode:u}=s;if(l.isLeaving)return ed(i);let c=eh(i);if(!c)return ed(i);let p=ef(c,s,l,r);em(c,p);let f=r.subTree,d=f&&eh(f),h=!1,{getTransitionKey:m}=c.type;if(m){let e=m();void 0===n?n=e:e!==n&&(n=e,h=!0)}if(d&&d.type!==tx&&(!tP(c,d)||h)){let e=ef(d,s,l,r);if(em(d,e),"out-in"===u)return l.isLeaving=!0,e.afterLeave=()=>{l.isLeaving=!1,!1!==r.update.active&&r.update()},ed(i);"in-out"===u&&c.type!==tx&&(e.delayLeave=(e,t,n)=>{let r=ep(l,d);r[String(d.key)]=d,e._leaveCb=()=>{t(),e._leaveCb=void 0,delete p.delayedLeave},p.delayedLeave=n})}return i}}};function ep(e,t){let{leavingVNodes:n}=e,r=n.get(t.type);return r||(r=/* @__PURE__ */Object.create(null),n.set(t.type,r)),r}function ef(e,t,n,r){let{appear:l,mode:o,persisted:i=!1,onBeforeEnter:s,onEnter:a,onAfterEnter:c,onEnterCancelled:p,onBeforeLeave:d,onLeave:h,onAfterLeave:m,onLeaveCancelled:g,onBeforeAppear:_,onAppear:y,onAfterAppear:x,onAppearCancelled:b}=t,O=String(e.key),w=ep(n,e),T=(e,t)=>{e&&f(e,r,9,t)},E=(e,t)=>{let n=t[1];T(e,t),(0,u.isArray)(e)?e.every(e=>e.length<=1)&&n():e.length<=1&&n()},C={mode:o,persisted:i,beforeEnter(t){let r=s;if(!n.isMounted){if(!l)return;r=_||s}t._leaveCb&&t._leaveCb(!0);let o=w[O];o&&tP(e,o)&&o.el._leaveCb&&o.el._leaveCb(),T(r,[t])},enter(e){let t=a,r=c,o=p;if(!n.isMounted){if(!l)return;t=y||a,r=x||c,o=b||p}let i=!1,s=e._enterCb=t=>{i||(i=!0,t?T(o,[e]):T(r,[e]),C.delayedLeave&&C.delayedLeave(),e._enterCb=void 0)};t?E(t,[e,s]):s()},leave(t,r){let l=String(e.key);if(t._enterCb&&t._enterCb(!0),n.isUnmounting)return r();T(d,[t]);let o=!1,i=t._leaveCb=n=>{o||(o=!0,r(),n?T(g,[t]):T(m,[t]),t._leaveCb=void 0,w[l]!==e||delete w[l])};w[l]=e,h?E(h,[t,i]):i()},clone:e=>ef(e,t,n,r)};return C}function ed(e){if(ey(e))return(e=tL(e)).children=null,e}function eh(e){return ey(e)?e.children?e.children[0]:void 0:e}function em(e,t){6&e.shapeFlag&&e.component?em(e.component.subTree,t):128&e.shapeFlag?(e.ssContent.transition=t.clone(e.ssContent),e.ssFallback.transition=t.clone(e.ssFallback)):e.transition=t}function eg(e,t=!1,n){let r=[],l=0;for(let o=0;o<e.length;o++){let i=e[o],s=null==n?i.key:String(n)+String(null!=i.key?i.key:o);i.type===t_?(128&i.patchFlag&&l++,r=r.concat(eg(i.children,t,s))):(t||i.type!==tx)&&r.push(null!=s?tL(i,{key:s}):i)}if(l>1)for(let e=0;e<r.length;e++)r[e].patchFlag=-2;return r}function ev(e,t){return(0,u.isFunction)(e)?(0,u.extend)({name:e.name},t,{setup:e}):e}let e_=e=>!!e.type.__asyncLoader,ey=e=>e.type.__isKeepAlive;function ex(e,t){eO(e,"a",t)}function eb(e,t){eO(e,"da",t)}function eO(e,t,n=tW){let r=e.__wdc||(e.__wdc=()=>{let t=n;for(;t;){if(t.isDeactivated)return;t=t.parent}return e()});if(ew(t,r,n),n){let e=n.parent;for(;e&&e.parent;)ey(e.parent.vnode)&&function(e,t,n,r){let l=ew(t,e,r,!0);eR(()=>{(0,u.remove)(r[t],l)},n)}(r,t,n,e),e=e.parent}}function ew(e,t,n=tW,r=!1){if(n){let l=n[e]||(n[e]=[]),o=t.__weh||(t.__weh=(...r)=>{if(n.isUnmounted)return;(0,a.pauseTracking)(),tY(n);let l=f(t,n,e,r);return tJ(),(0,a.resetTracking)(),l});return r?l.unshift(o):l.push(o),o}}let eT=e=>(t,n=tW)=>(!tq||"sp"===e)&&ew(e,(...e)=>t(...e),n),eE=eT("bm"),eC=eT("m"),eS=eT("bu"),ek=eT("u"),eP=eT("bum"),eR=eT("um"),eA=eT("sp"),eV=eT("rtg"),eF=eT("rtc");function eN(e,t=tW){ew("ec",e,t)}let eL="components";function eM(e,t){return function(e,t,n=!0,r=!1){let l=$||tW;if(l){let n=l.type;if(e===eL){let e=function(e,t=!0){return(0,u.isFunction)(e)?e.displayName||e.name:e.name||t&&e.__name}(n,!1);if(e&&(e===t||e===(0,u.camelize)(t)||e===(0,u.capitalize)((0,u.camelize)(t))))return n}let o=// check instance[type] first which is resolved for options API
eI(l[e]||n[e],t)||// global registration
eI(l.appContext[e],t);return!o&&r?n:o}}(eL,e,!0,t)||e}let ej=Symbol.for("v-ndc");function eI(e,t){return e&&(e[t]||e[(0,u.camelize)(t)]||e[(0,u.capitalize)((0,u.camelize)(t))])}function eB(e,t,n,r){let l;let o=n&&n[r];if((0,u.isArray)(e)||(0,u.isString)(e)){l=Array(e.length);for(let n=0,r=e.length;n<r;n++)l[n]=t(e[n],n,void 0,o&&o[n])}else if("number"==typeof e){l=Array(e);for(let n=0;n<e;n++)l[n]=t(n+1,n,void 0,o&&o[n])}else if((0,u.isObject)(e)){if(e[Symbol.iterator])l=Array.from(e,(e,n)=>t(e,n,void 0,o&&o[n]));else{let n=Object.keys(e);l=Array(n.length);for(let r=0,i=n.length;r<i;r++){let i=n[r];l[r]=t(e[i],i,r,o&&o[r])}}}else l=[];return n&&(n[r]=l),l}let eD=e=>e?tG(e)?t0(e)||e.proxy:eD(e.parent):null,eU=// due to type annotation
/* @__PURE__ */(0,u.extend)(/* @__PURE__ */Object.create(null),{$:e=>e,$el:e=>e.vnode.el,$data:e=>e.data,$props:e=>e.props,$attrs:e=>e.attrs,$slots:e=>e.slots,$refs:e=>e.refs,$parent:e=>eD(e.parent),$root:e=>eD(e.root),$emit:e=>e.emit,$options:e=>__VUE_OPTIONS_API__?eY(e):e.type,$forceUpdate:e=>e.f||(e.f=()=>C(e.update)),$nextTick:e=>e.n||(e.n=E.bind(e.proxy)),$watch:e=>__VUE_OPTIONS_API__?er.bind(e):u.NOOP}),e$=(e,t)=>e!==u.EMPTY_OBJ&&!e.__isScriptSetup&&(0,u.hasOwn)(e,t),eQ={get({_:e},t){let n,r,l;let{ctx:o,setupState:i,data:s,props:c,accessCache:p,type:f,appContext:d}=e;if("$"!==t[0]){let r=p[t];if(void 0!==r)switch(r){case 1/* SETUP */:return i[t];case 2/* DATA */:return s[t];case 4/* CONTEXT */:return o[t];case 3/* PROPS */:return c[t]}else{if(e$(i,t))return p[t]=1/* SETUP */,i[t];if(s!==u.EMPTY_OBJ&&(0,u.hasOwn)(s,t))return p[t]=2/* DATA */,s[t];if(// props
(n=e.propsOptions[0])&&(0,u.hasOwn)(n,t))return p[t]=3/* PROPS */,c[t];if(o!==u.EMPTY_OBJ&&(0,u.hasOwn)(o,t))return p[t]=4/* CONTEXT */,o[t];(!__VUE_OPTIONS_API__||eH)&&(p[t]=0/* OTHER */)}}let h=eU[t];return h?("$attrs"===t&&(0,a.track)(e,"get",t),h(e)):(r=f.__cssModules)&&(r=r[t])?r:o!==u.EMPTY_OBJ&&(0,u.hasOwn)(o,t)?(p[t]=4/* CONTEXT */,o[t]):(l=d.config.globalProperties,(0,u.hasOwn)(l,t))?l[t]:void 0},set({_:e},t,n){let{data:r,setupState:l,ctx:o}=e;return e$(l,t)?(l[t]=n,!0):r!==u.EMPTY_OBJ&&(0,u.hasOwn)(r,t)?(r[t]=n,!0):!(0,u.hasOwn)(e.props,t)&&!("$"===t[0]&&t.slice(1) in e)&&(o[t]=n,!0)},has({_:{data:e,setupState:t,accessCache:n,ctx:r,appContext:l,propsOptions:o}},i){let s;return!!n[i]||e!==u.EMPTY_OBJ&&(0,u.hasOwn)(e,i)||e$(t,i)||(s=o[0])&&(0,u.hasOwn)(s,i)||(0,u.hasOwn)(r,i)||(0,u.hasOwn)(eU,i)||(0,u.hasOwn)(l.config.globalProperties,i)},defineProperty(e,t,n){return null!=n.get?e._.accessCache[t]=0:(0,u.hasOwn)(n,"value")&&this.set(e,t,n.value,null),Reflect.defineProperty(e,t,n)}};function eW(e){return(0,u.isArray)(e)?e.reduce((e,t)=>(e[t]=null,e),{}):e}let eH=!0;function ez(e,t,n){f((0,u.isArray)(e)?e.map(e=>e.bind(t.proxy)):e.bind(t.proxy),t,n)}function eY(e){let t;let n=e.type,{mixins:r,extends:l}=n,{mixins:o,optionsCache:i,config:{optionMergeStrategies:s}}=e.appContext,a=i.get(n);return a?t=a:o.length||r||l?(t={},o.length&&o.forEach(e=>eJ(t,e,s,!0)),eJ(t,n,s)):t=n,(0,u.isObject)(n)&&i.set(n,t),t}function eJ(e,t,n,r=!1){let{mixins:l,extends:o}=t;for(let i in o&&eJ(e,o,n,!0),l&&l.forEach(t=>eJ(e,t,n,!0)),t)if(r&&"expose"===i);else{let r=eG[i]||n&&n[i];e[i]=r?r(e[i],t[i]):t[i]}return e}let eG={data:eq,props:e0,emits:e0,// objects
methods:eZ,computed:eZ,// lifecycle
beforeCreate:eX,created:eX,beforeMount:eX,mounted:eX,beforeUpdate:eX,updated:eX,beforeDestroy:eX,beforeUnmount:eX,destroyed:eX,unmounted:eX,activated:eX,deactivated:eX,errorCaptured:eX,serverPrefetch:eX,// assets
components:eZ,directives:eZ,// watch
watch:function(e,t){if(!e)return t;if(!t)return e;let n=(0,u.extend)(/* @__PURE__ */Object.create(null),e);for(let r in t)n[r]=eX(e[r],t[r]);return n},// provide / inject
provide:eq,inject:function(e,t){return eZ(eK(e),eK(t))}};function eq(e,t){return t?e?function(){return(0,u.extend)((0,u.isFunction)(e)?e.call(this,this):e,(0,u.isFunction)(t)?t.call(this,this):t)}:t:e}function eK(e){if((0,u.isArray)(e)){let t={};for(let n=0;n<e.length;n++)t[e[n]]=e[n];return t}return e}function eX(e,t){return e?[...new Set([].concat(e,t))]:t}function eZ(e,t){return e?(0,u.extend)(/* @__PURE__ */Object.create(null),e,t):t}function e0(e,t){return e?(0,u.isArray)(e)&&(0,u.isArray)(t)?[.../* @__PURE__ */new Set([...e,...t])]:(0,u.extend)(/* @__PURE__ */Object.create(null),eW(e),eW(null!=t?t:{})):t}function e1(){return{app:null,config:{isNativeTag:u.NO,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:/* @__PURE__ */Object.create(null),optionsCache:/* @__PURE__ */new WeakMap,propsCache:/* @__PURE__ */new WeakMap,emitsCache:/* @__PURE__ */new WeakMap}}let e2=0,e8=null;function e3(e,t){if(tW){let n=tW.provides,r=tW.parent&&tW.parent.provides;r===n&&(n=tW.provides=Object.create(r)),n[e]=t}}function e4(e,t,n=!1){let r=tW||$;if(r||e8){let l=r?null==r.parent?r.vnode.appContext&&r.vnode.appContext.provides:r.parent.provides:e8._context.provides;if(l&&e in l)return l[e];if(arguments.length>1)return n&&(0,u.isFunction)(t)?t.call(r&&r.proxy):t}}function e6(e,t,n,r){let l;let[o,i]=e.propsOptions,s=!1;if(t)for(let a in t){let c;if((0,u.isReservedProp)(a))continue;let p=t[a];o&&(0,u.hasOwn)(o,c=(0,u.camelize)(a))?i&&i.includes(c)?(l||(l={}))[c]=p:n[c]=p:U(e.emitsOptions,a)||a in r&&p===r[a]||(r[a]=p,s=!0)}if(i){let t=(0,a.toRaw)(n),r=l||u.EMPTY_OBJ;for(let l=0;l<i.length;l++){let s=i[l];n[s]=e5(o,t,s,r[s],e,!(0,u.hasOwn)(r,s))}}return s}function e5(e,t,n,r,l,o){let i=e[n];if(null!=i){let e=(0,u.hasOwn)(i,"default");if(e&&void 0===r){let e=i.default;if(i.type!==Function&&!i.skipFactory&&(0,u.isFunction)(e)){let{propsDefaults:o}=l;n in o?r=o[n]:(tY(l),r=o[n]=e.call(null,t),tJ())}else r=e}i[0/* shouldCast */]&&(o&&!e?r=!1:i[1/* shouldCastTrue */]&&(""===r||r===(0,u.hyphenate)(n))&&(r=!0))}return r}function e7(e){let t=e&&e.toString().match(/^\s*(function|class) (\w+)/);return t?t[2]:null===e?"null":""}function e9(e,t){return(0,u.isArray)(t)?t.findIndex(t=>e7(t)===e7(e)):(0,u.isFunction)(t)?e7(t)===e7(e)?0:-1:-1}let te=e=>"_"===e[0]||"$stable"===e,tt=e=>(0,u.isArray)(e)?e.map(tI):[tI(e)],tn=(e,t,n)=>{if(t._n)return t;let r=H((...e)=>tt(t(...e)),n);return r._c=!1,r},tr=(e,t,n)=>{let r=e._ctx;for(let n in e){if(te(n))continue;let l=e[n];if((0,u.isFunction)(l))t[n]=tn(n,l,r);else if(null!=l){let e=tt(l);t[n]=()=>e}}},tl=(e,t)=>{let n=tt(t);e.slots.default=()=>n},to=(e,t)=>{if(32&e.vnode.shapeFlag){let n=t._;n?(e.slots=(0,a.toRaw)(t),(0,u.def)(t,"_",n)):tr(t,e.slots={})}else e.slots={},t&&tl(e,t);(0,u.def)(e.slots,tR,1)},ti=(e,t,n)=>{let{vnode:r,slots:l}=e,o=!0,i=u.EMPTY_OBJ;if(32&r.shapeFlag){let e=t._;e?n&&1===e?o=!1:((0,u.extend)(l,t),n||1!==e||delete l._):(o=!t.$stable,tr(t,l)),i=t}else t&&(tl(e,t),i={default:1});if(o)for(let e in l)te(e)||e in i||delete l[e]};function ts(e,t,n,r,l=!1){if((0,u.isArray)(e)){e.forEach((e,o)=>ts(e,t&&((0,u.isArray)(t)?t[o]:t),n,r,l));return}if(e_(r)&&!l)return;let o=4&r.shapeFlag?t0(r.component)||r.component.proxy:r.el,i=l?null:o,{i:s,r:c}=e,f=t&&t.r,d=s.refs===u.EMPTY_OBJ?s.refs={}:s.refs,h=s.setupState;if(null!=f&&f!==c&&((0,u.isString)(f)?(d[f]=null,(0,u.hasOwn)(h,f)&&(h[f]=null)):(0,a.isRef)(f)&&(f.value=null)),(0,u.isFunction)(c))p(c,s,12,[i,d]);else{let t=(0,u.isString)(c),r=(0,a.isRef)(c);if(t||r){let s=()=>{if(e.f){let n=t?(0,u.hasOwn)(h,c)?h[c]:d[c]:c.value;l?(0,u.isArray)(n)&&(0,u.remove)(n,o):(0,u.isArray)(n)?n.includes(o)||n.push(o):t?(d[c]=[o],(0,u.hasOwn)(h,c)&&(h[c]=d[c])):(c.value=[o],e.k&&(d[e.k]=c.value))}else t?(d[c]=i,(0,u.hasOwn)(h,c)&&(h[c]=i)):r&&(c.value=i,e.k&&(d[e.k]=i))};i?(s.id=-1,tf(s,n)):s()}}}let ta=!1,tu=e=>/svg/.test(e.namespaceURI)&&"foreignObject"!==e.tagName,tc=e=>8/* COMMENT */===e.nodeType;function tp(e){let{mt:t,p:n,o:{patchProp:r,createText:l,nextSibling:o,parentNode:i,remove:s,insert:a,createComment:c}}=e,p=(n,r,s,u,c,_=!1)=>{let y=tc(n)&&"["===n.data,x=()=>m(n,r,s,u,c,y),{type:b,ref:O,shapeFlag:w,patchFlag:T}=r,E=n.nodeType;r.el=n,-2===T&&(_=!1,r.dynamicChildren=null);let C=null;switch(b){case ty:3/* TEXT */!==E?""===r.children?(a(r.el=l(""),i(n),n),C=n):C=x():(n.data!==r.children&&(ta=!0,n.data=r.children),C=o(n));break;case tx:C=8/* COMMENT */!==E||y?x():o(n);break;case tb:if(y&&(E=(n=o(n)).nodeType),1/* ELEMENT */===E||3/* TEXT */===E){C=n;let e=!r.children.length;for(let t=0;t<r.staticCount;t++)e&&(r.children+=1/* ELEMENT */===C.nodeType?C.outerHTML:C.data),t===r.staticCount-1&&(r.anchor=C),C=o(C);return y?o(C):C}x();break;case t_:C=y?h(n,r,s,u,c,_):x();break;default:if(1&w)C=1/* ELEMENT */!==E||r.type.toLowerCase()!==n.tagName.toLowerCase()?x():f(n,r,s,u,c,_);else if(6&w){r.slotScopeIds=c;let e=i(n);if(t(r,e,null,s,u,tu(e),_),(C=y?g(n):o(n))&&tc(C)&&"teleport end"===C.data&&(C=o(C)),e_(r)){let t;y?(t=tN(t_)).anchor=C?C.previousSibling:e.lastChild:t=3===n.nodeType?tM(""):tN("div"),t.el=n,r.component.subTree=t}}else 64&w?C=8/* COMMENT */!==E?x():r.type.hydrate(n,r,s,u,c,_,e,d):128&w&&(C=r.type.hydrate(n,r,s,u,tu(i(n)),c,_,e,p))}return null!=O&&ts(O,null,u,r),C},f=(e,t,n,l,o,i)=>{i=i||!!t.dynamicChildren;let{type:a,props:c,patchFlag:p,shapeFlag:f,dirs:h}=t,m="input"===a&&h||"option"===a;if(m||-1!==p){let a;if(h&&ei(t,null,n,"created"),c){if(m||!i||48&p)for(let t in c)(m&&t.endsWith("value")||(0,u.isOn)(t)&&!(0,u.isReservedProp)(t))&&r(e,t,null,c[t],!1,void 0,n);else c.onClick&&r(e,"onClick",null,c.onClick,!1,void 0,n)}if((a=c&&c.onVnodeBeforeMount)&&tU(a,n,t),h&&ei(t,null,n,"beforeMount"),((a=c&&c.onVnodeMounted)||h)&&K(()=>{a&&tU(a,n,t),h&&ei(t,null,n,"mounted")},l),16&f&&// skip if element has innerHTML / textContent
!(c&&(c.innerHTML||c.textContent))){let r=d(e.firstChild,t,e,n,l,o,i);for(;r;){ta=!0;let e=r;r=r.nextSibling,s(e)}}else 8&f&&e.textContent!==t.children&&(ta=!0,e.textContent=t.children)}return e.nextSibling},d=(e,t,r,l,o,i,s)=>{s=s||!!t.dynamicChildren;let a=t.children,u=a.length;for(let t=0;t<u;t++){let u=s?a[t]:a[t]=tI(a[t]);if(e)e=p(e,u,l,o,i,s);else{if(u.type===ty&&!u.children)continue;ta=!0,n(null,u,r,null,l,o,tu(r),i)}}return e},h=(e,t,n,r,l,s)=>{let{slotScopeIds:u}=t;u&&(l=l?l.concat(u):u);let p=i(e),f=d(o(e),t,p,n,r,l,s);return f&&tc(f)&&"]"===f.data?o(t.anchor=f):(ta=!0,a(t.anchor=c("]"),p,f),f)},m=(e,t,r,l,a,u)=>{if(ta=!0,t.el=null,u){let t=g(e);for(;;){let n=o(e);if(n&&n!==t)s(n);else break}}let c=o(e),p=i(e);return s(e),n(null,t,p,c,r,l,tu(p),a),c},g=e=>{let t=0;for(;e;)if((e=o(e))&&tc(e)&&("["===e.data&&t++,"]"===e.data)){if(0===t)return o(e);t--}return e};return[(e,t)=>{if(!t.hasChildNodes()){n(null,e,t),P(),t._vnode=e;return}ta=!1,p(t.firstChild,e,null,null,null),P(),t._vnode=e,ta&&console.error("Hydration completed but contains mismatches.")},p]}let tf=K;function td(e){return tm(e)}function th(e){return tm(e,tp)}function tm(e,t){var r;let l,o;"boolean"!=typeof __VUE_OPTIONS_API__&&((0,u.getGlobalThis)().__VUE_OPTIONS_API__=!0),"boolean"!=typeof __VUE_PROD_DEVTOOLS__&&((0,u.getGlobalThis)().__VUE_PROD_DEVTOOLS__=!1);let i=(0,u.getGlobalThis)();i.__VUE__=!0,__VUE_PROD_DEVTOOLS__&&function e(t,r){var l,o;if(n=t)n.enabled=!0,V.forEach(({event:e,args:t})=>n.emit(e,...t)),V=[];else if(// browser environment to avoid the timer handle stalling test runner exit
// (#4815)
"undefined"==typeof window||!// some envs mock window but not fully
window.HTMLElement||(null==(o=null==(l=window.navigator)?void 0:l.userAgent)?void 0:o.includes("jsdom")))F=!0,V=[];else{let t=r.__VUE_DEVTOOLS_HOOK_REPLAY__=r.__VUE_DEVTOOLS_HOOK_REPLAY__||[];t.push(t=>{e(t,r)}),setTimeout(()=>{n||(r.__VUE_DEVTOOLS_HOOK_REPLAY__=null,F=!0,V=[])},3e3)}}(i.__VUE_DEVTOOLS_GLOBAL_HOOK__,i);let{insert:s,remove:c,patchProp:f,createElement:h,createText:m,createComment:g,setText:x,setElementText:b,parentNode:O,nextSibling:w,setScopeId:T=u.NOOP,insertStaticContent:E}=e,S=(e,t,n,r=null,l=null,o=null,i=!1,s=null,a=!!t.dynamicChildren)=>{if(e===t)return;e&&!tP(e,t)&&(r=eh(e),eu(e,l,o,!0),e=null),-2===t.patchFlag&&(a=!1,t.dynamicChildren=null);let{type:u,ref:c,shapeFlag:p}=t;switch(u){case ty:R(e,t,n,r);break;case tx:A(e,t,n,r);break;case tb:null==e&&j(t,n,r,i);break;case t_:X(e,t,n,r,l,o,i,s,a);break;default:1&p?Q(e,t,n,r,l,o,i,s,a):6&p?Z(e,t,n,r,l,o,i,s,a):64&p?u.process(e,t,n,r,l,o,i,s,a,eg):128&p&&u.process(e,t,n,r,l,o,i,s,a,eg)}null!=c&&l&&ts(c,e&&e.ref,o,t||e,!t)},R=(e,t,n,r)=>{if(null==e)s(t.el=m(t.children),n,r);else{let n=t.el=e.el;t.children!==e.children&&x(n,t.children)}},A=(e,t,n,r)=>{null==e?s(t.el=g(t.children||""),n,r):t.el=e.el},j=(e,t,n,r)=>{[e.el,e.anchor]=E(e.children,t,n,r,e.el,e.anchor)},B=({el:e,anchor:t},n,r)=>{let l;for(;e&&e!==t;)l=w(e),s(e,n,r),e=l;s(t,n,r)},$=({el:e,anchor:t})=>{let n;for(;e&&e!==t;)n=w(e),c(e),e=n;c(t)},Q=(e,t,n,r,l,o,i,s,a)=>{i=i||"svg"===t.type,null==e?W(t,n,r,l,o,i,s,a):J(e,t,l,o,i,s,a)},W=(e,t,n,r,l,o,i,a)=>{let c,p;let{type:d,props:m,shapeFlag:g,transition:_,dirs:y}=e;if(c=e.el=h(e.type,o,m&&m.is,m),8&g?b(c,e.children):16&g&&Y(e.children,c,null,r,l,o&&"foreignObject"!==d,i,a),y&&ei(e,null,r,"created"),H(c,e,e.scopeId,i,r),m){for(let t in m)"value"===t||(0,u.isReservedProp)(t)||f(c,t,null,m[t],o,e.children,r,l,ed);"value"in m&&f(c,"value",null,m.value),(p=m.onVnodeBeforeMount)&&tU(p,r,e)}__VUE_PROD_DEVTOOLS__&&(Object.defineProperty(c,"__vnode",{value:e,enumerable:!1}),Object.defineProperty(c,"__vueParentComponent",{value:r,enumerable:!1})),y&&ei(e,null,r,"beforeMount");let x=(!l||l&&!l.pendingBranch)&&_&&!_.persisted;x&&_.beforeEnter(c),s(c,t,n),((p=m&&m.onVnodeMounted)||x||y)&&tf(()=>{p&&tU(p,r,e),x&&_.enter(c),y&&ei(e,null,r,"mounted")},l)},H=(e,t,n,r,l)=>{if(n&&T(e,n),r)for(let t=0;t<r.length;t++)T(e,r[t]);if(l&&t===l.subTree){let t=l.vnode;H(e,t,t.scopeId,t.slotScopeIds,l.parent)}},Y=(e,t,n,r,l,o,i,s,a=0)=>{for(let u=a;u<e.length;u++){let a=e[u]=s?tB(e[u]):tI(e[u]);S(null,a,t,n,r,l,o,i,s)}},J=(e,t,n,r,l,o,i)=>{let s;let a=t.el=e.el,{patchFlag:c,dynamicChildren:p,dirs:d}=t;c|=16&e.patchFlag;let h=e.props||u.EMPTY_OBJ,m=t.props||u.EMPTY_OBJ;n&&tg(n,!1),(s=m.onVnodeBeforeUpdate)&&tU(s,n,t,e),d&&ei(t,e,n,"beforeUpdate"),n&&tg(n,!0);let g=l&&"foreignObject"!==t.type;if(p?q(e.dynamicChildren,p,a,n,r,g,o):i||el(e,t,a,null,n,r,g,o,!1),c>0){if(16&c)K(a,t,h,m,n,r,l);else if(2&c&&h.class!==m.class&&f(a,"class",null,m.class,l),4&c&&f(a,"style",h.style,m.style,l),8&c){let o=t.dynamicProps;for(let t=0;t<o.length;t++){let i=o[t],s=h[i],u=m[i];(u!==s||"value"===i)&&f(a,i,s,u,l,e.children,n,r,ed)}}1&c&&e.children!==t.children&&b(a,t.children)}else i||null!=p||K(a,t,h,m,n,r,l);((s=m.onVnodeUpdated)||d)&&tf(()=>{s&&tU(s,n,t,e),d&&ei(t,e,n,"updated")},r)},q=(e,t,n,r,l,o,i)=>{for(let s=0;s<t.length;s++){let a=e[s],u=t[s],c=// which will not have a mounted element
a.el&&// - In the case of a Fragment, we need to provide the actual parent
// of the Fragment itself so it can move its children.
(a.type===t_||// - In the case of different nodes, there is going to be a replacement
// which also requires the correct parent container
!tP(a,u)||// - In the case of a component, it could contain anything.
70&a.shapeFlag)?O(a.el):// just pass the block element here to avoid a DOM parentNode call.
n;S(a,u,c,null,r,l,o,i,!0)}},K=(e,t,n,r,l,o,i)=>{if(n!==r){if(n!==u.EMPTY_OBJ)for(let s in n)(0,u.isReservedProp)(s)||s in r||f(e,s,n[s],null,i,t.children,l,o,ed);for(let s in r){if((0,u.isReservedProp)(s))continue;let a=r[s],c=n[s];a!==c&&"value"!==s&&f(e,s,c,a,i,t.children,l,o,ed)}"value"in r&&f(e,"value",n.value,r.value)}},X=(e,t,n,r,l,o,i,a,c)=>{let p=t.el=e?e.el:m(""),f=t.anchor=e?e.anchor:m(""),{patchFlag:d,dynamicChildren:h,slotScopeIds:g}=t;g&&(a=a?a.concat(g):g),null==e?(s(p,n,r),s(f,n,r),Y(t.children,n,f,l,o,i,a,c)):d>0&&64&d&&h&&// #2715 the previous fragment could've been a BAILed one as a result
// of renderSlot() with no valid children
e.dynamicChildren?(q(e.dynamicChildren,h,n,l,o,i,a),//  get moved around. Make sure all root level vnodes inherit el.
// #2134 or if it's a component root, it may also get moved around
// as the component is being moved.
(null!=t.key||l&&t===l.subTree)&&function e(t,n,r=!1){let l=t.children,o=n.children;if((0,u.isArray)(l)&&(0,u.isArray)(o))for(let t=0;t<l.length;t++){let n=l[t],i=o[t];!(1&i.shapeFlag)||i.dynamicChildren||((i.patchFlag<=0||32===i.patchFlag)&&((i=o[t]=tB(o[t])).el=n.el),r||e(n,i)),i.type===ty&&(i.el=n.el)}}(e,t,!0)):el(e,t,n,f,l,o,i,a,c)},Z=(e,t,n,r,l,o,i,s,a)=>{t.slotScopeIds=s,null==e?512&t.shapeFlag?l.ctx.activate(t,n,r,i,a):ee(t,n,r,l,o,i,a):et(e,t,a)},ee=(e,t,n,r,l,o,i)=>{let s=e.component=function(e,t,n){let r=e.type,l=(t?t.appContext:e.appContext)||t$,o={uid:tQ++,vnode:e,type:r,parent:t,appContext:l,root:null,// to be immediately set
next:null,subTree:null,// will be set synchronously right after creation
effect:null,update:null,// will be set synchronously right after creation
scope:new a.EffectScope(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:t?t.provides:Object.create(l.provides),accessCache:null,renderCache:[],// local resolved assets
components:null,directives:null,// resolved props and emits options
propsOptions:function e(t,n,r=!1){let l=n.propsCache,o=l.get(t);if(o)return o;let i=t.props,s={},a=[],c=!1;if(__VUE_OPTIONS_API__&&!(0,u.isFunction)(t)){let l=t=>{c=!0;let[r,l]=e(t,n,!0);(0,u.extend)(s,r),l&&a.push(...l)};!r&&n.mixins.length&&n.mixins.forEach(l),t.extends&&l(t.extends),t.mixins&&t.mixins.forEach(l)}if(!i&&!c)return(0,u.isObject)(t)&&l.set(t,u.EMPTY_ARR),u.EMPTY_ARR;if((0,u.isArray)(i))for(let e=0;e<i.length;e++){let t=(0,u.camelize)(i[e]);"$"!==t[0]&&(s[t]=u.EMPTY_OBJ)}else if(i)for(let e in i){let t=(0,u.camelize)(e);if("$"!==t[0]){let n=i[e],r=s[t]=(0,u.isArray)(n)||(0,u.isFunction)(n)?{type:n}:(0,u.extend)({},n);if(r){let e=e9(Boolean,r.type),n=e9(String,r.type);r[0/* shouldCast */]=e>-1,r[1/* shouldCastTrue */]=n<0||e<n,(e>-1||(0,u.hasOwn)(r,"default"))&&a.push(t)}}}let p=[s,a];return(0,u.isObject)(t)&&l.set(t,p),p}(r,l),emitsOptions:function e(t,n,r=!1){let l=n.emitsCache,o=l.get(t);if(void 0!==o)return o;let i=t.emits,s={},a=!1;if(__VUE_OPTIONS_API__&&!(0,u.isFunction)(t)){let l=t=>{let r=e(t,n,!0);r&&(a=!0,(0,u.extend)(s,r))};!r&&n.mixins.length&&n.mixins.forEach(l),t.extends&&l(t.extends),t.mixins&&t.mixins.forEach(l)}return i||a?((0,u.isArray)(i)?i.forEach(e=>s[e]=null):(0,u.extend)(s,i),(0,u.isObject)(t)&&l.set(t,s),s):((0,u.isObject)(t)&&l.set(t,null),null)}(r,l),// emit
emit:null,// to be set immediately
emitted:null,// props default value
propsDefaults:u.EMPTY_OBJ,// inheritAttrs
inheritAttrs:r.inheritAttrs,// state
ctx:u.EMPTY_OBJ,data:u.EMPTY_OBJ,props:u.EMPTY_OBJ,attrs:u.EMPTY_OBJ,slots:u.EMPTY_OBJ,refs:u.EMPTY_OBJ,setupState:u.EMPTY_OBJ,setupContext:null,attrsProxy:null,slotsProxy:null,suspense:n,suspenseId:n?n.pendingId:0,asyncDep:null,asyncResolved:!1,// lifecycle hooks
// not using enums here because it results in computed properties
isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return o.ctx={_:o},o.root=t?t.root:o,o.emit=D.bind(null,o),e.ce&&e.ce(o),o}(e,r,l);if(ey(e)&&(s.ctx.renderer=eg),function(e,t=!1){tq=t;let{props:n,children:r}=e.vnode,l=tG(e);(function(e,t,n,r=!1){let l={},o={};for(let n in(0,u.def)(o,tR,1),e.propsDefaults=/* @__PURE__ */Object.create(null),e6(e,t,l,o),e.propsOptions[0])n in l||(l[n]=void 0);n?e.props=r?l:(0,a.shallowReactive)(l):e.type.props?e.props=l:e.props=o,e.attrs=o})(e,n,l,t),to(e,r),l&&function(e,t){let n=e.type;e.accessCache=/* @__PURE__ */Object.create(null),e.proxy=(0,a.markRaw)(new Proxy(e.ctx,eQ));let{setup:r}=n;if(r){var l;let n=e.setupContext=r.length>1?{get attrs(){return l.attrsProxy||(l.attrsProxy=new Proxy(l.attrs,{get:(e,t)=>((0,a.track)(l,"get","$attrs"),e[t])}))},slots:(l=e).slots,emit:l.emit,expose:e=>{l.exposed=e||{}}}:null;tY(e),(0,a.pauseTracking)();let o=p(r,e,0,[e.props,n]);if((0,a.resetTracking)(),tJ(),(0,u.isPromise)(o)){if(o.then(tJ,tJ),t)return o.then(n=>{tK(e,n,t)}).catch(t=>{d(t,e,0)});e.asyncDep=o}else tK(e,o,t)}else tZ(e,t)}(e,t),tq=!1}(s),s.asyncDep){if(l&&l.registerDep(s,en),!e.el){let e=s.subTree=tN(tx);A(null,e,t,n)}return}en(s,e,t,n,l,o,i)},et=(e,t,n)=>{let r=t.component=e.component;if(function(e,t,n){let{props:r,children:l,component:o}=e,{props:i,children:s,patchFlag:a}=t,u=o.emitsOptions;if(t.dirs||t.transition)return!0;if(!n||!(a>=0))return(!!l||!!s)&&(!s||!s.$stable)||r!==i&&(r?!i||G(r,i,u):!!i);if(1024&a)return!0;if(16&a)return r?G(r,i,u):!!i;if(8&a){let e=t.dynamicProps;for(let t=0;t<e.length;t++){let n=e[t];if(i[n]!==r[n]&&!U(u,n))return!0}}return!1}(e,t,n)){if(r.asyncDep&&!r.asyncResolved){er(r,t,n);return}r.next=t,function(e){let t=_.indexOf(e);t>y&&_.splice(t,1)}(r.update),r.update()}else t.el=e.el,r.vnode=t},en=(e,t,n,r,l,i,s)=>{let c=e.effect=new a.ReactiveEffect(()=>{if(e.isMounted){let t,{next:n,bu:r,u:o,parent:a,vnode:c}=e,p=n;tg(e,!1),n?(n.el=c.el,er(e,n,s)):n=c,r&&(0,u.invokeArrayFns)(r),(t=n.props&&n.props.onVnodeBeforeUpdate)&&tU(t,a,n,c),tg(e,!0);let f=z(e),d=e.subTree;e.subTree=f,S(d,f,O(d.el),eh(d),e,l,i),n.el=f.el,null===p&&function({vnode:e,parent:t},n){for(;t&&t.subTree===e;)(e=t.vnode).el=n,t=t.parent}(e,f.el),o&&tf(o,l),(t=n.props&&n.props.onVnodeUpdated)&&tf(()=>tU(t,a,n,c),l),__VUE_PROD_DEVTOOLS__&&M(e)}else{let s;let{el:a,props:c}=t,{bm:p,m:f,parent:d}=e,h=e_(t);if(tg(e,!1),p&&(0,u.invokeArrayFns)(p),!h&&(s=c&&c.onVnodeBeforeMount)&&tU(s,d,t),tg(e,!0),a&&o){let n=()=>{e.subTree=z(e),o(a,e.subTree,e,l,null)};h?t.type.__asyncLoader().then(// which means it won't track dependencies - but it's ok because
// a server-rendered async wrapper is already in resolved state
// and it will never need to change.
()=>!e.isUnmounted&&n()):n()}else{let o=e.subTree=z(e);S(null,o,n,r,e,l,i),t.el=o.el}if(f&&tf(f,l),!h&&(s=c&&c.onVnodeMounted)){let e=t;tf(()=>tU(s,d,e),l)}(256&t.shapeFlag||d&&e_(d.vnode)&&256&d.vnode.shapeFlag)&&e.a&&tf(e.a,l),e.isMounted=!0,__VUE_PROD_DEVTOOLS__&&L(e),t=n=r=null}},()=>C(p),e.scope),p=e.update=()=>c.run();p.id=e.uid,tg(e,!0),p()},er=(e,t,n)=>{t.component=e;let r=e.vnode.props;e.vnode=t,e.next=null,function(e,t,n,r){let{props:l,attrs:o,vnode:{patchFlag:i}}=e,s=(0,a.toRaw)(l),[c]=e.propsOptions,p=!1;if(// - #1942 if hmr is enabled with sfc component
// - vite#872 non-sfc component used by sfc component
(r||i>0)&&!(16&i)){if(8&i){let n=e.vnode.dynamicProps;for(let r=0;r<n.length;r++){let i=n[r];if(U(e.emitsOptions,i))continue;let a=t[i];if(c){if((0,u.hasOwn)(o,i))a!==o[i]&&(o[i]=a,p=!0);else{let t=(0,u.camelize)(i);l[t]=e5(c,s,t,a,e,!1)}}else a!==o[i]&&(o[i]=a,p=!0)}}}else{let r;for(let i in e6(e,t,l,o)&&(p=!0),s)t&&// for camelCase
((0,u.hasOwn)(t,i)||// it's possible the original props was passed in as kebab-case
// and converted to camelCase (#955)
(r=(0,u.hyphenate)(i))!==i&&(0,u.hasOwn)(t,r))||(c?n&&// for camelCase
(void 0!==n[i]||// for kebab-case
void 0!==n[r])&&(l[i]=e5(c,s,i,void 0,e,!0)):delete l[i]);if(o!==s)for(let e in o)t&&(0,u.hasOwn)(t,e)||(delete o[e],p=!0)}p&&(0,a.trigger)(e,"set","$attrs")}(e,t.props,r,n),ti(e,t.children,n),(0,a.pauseTracking)(),k(),(0,a.resetTracking)()},el=(e,t,n,r,l,o,i,s,a=!1)=>{let u=e&&e.children,c=e?e.shapeFlag:0,p=t.children,{patchFlag:f,shapeFlag:d}=t;if(f>0){if(128&f){es(u,p,n,r,l,o,i,s,a);return}if(256&f){eo(u,p,n,r,l,o,i,s,a);return}}8&d?(16&c&&ed(u,l,o),p!==u&&b(n,p)):16&c?16&d?es(u,p,n,r,l,o,i,s,a):ed(u,l,o,!0):(8&c&&b(n,""),16&d&&Y(p,n,r,l,o,i,s,a))},eo=(e,t,n,r,l,o,i,s,a)=>{let c;e=e||u.EMPTY_ARR,t=t||u.EMPTY_ARR;let p=e.length,f=t.length,d=Math.min(p,f);for(c=0;c<d;c++){let r=t[c]=a?tB(t[c]):tI(t[c]);S(e[c],r,n,null,l,o,i,s,a)}p>f?ed(e,l,o,!0,!1,d):Y(t,n,r,l,o,i,s,a,d)},es=(e,t,n,r,l,o,i,s,a)=>{let c=0,p=t.length,f=e.length-1,d=p-1;for(;c<=f&&c<=d;){let r=e[c],u=t[c]=a?tB(t[c]):tI(t[c]);if(tP(r,u))S(r,u,n,null,l,o,i,s,a);else break;c++}for(;c<=f&&c<=d;){let r=e[f],u=t[d]=a?tB(t[d]):tI(t[d]);if(tP(r,u))S(r,u,n,null,l,o,i,s,a);else break;f--,d--}if(c>f){if(c<=d){let e=d+1,u=e<p?t[e].el:r;for(;c<=d;)S(null,t[c]=a?tB(t[c]):tI(t[c]),n,u,l,o,i,s,a),c++}}else if(c>d)for(;c<=f;)eu(e[c],l,o,!0),c++;else{let h;let m=c,g=c,_=/* @__PURE__ */new Map;for(c=g;c<=d;c++){let e=t[c]=a?tB(t[c]):tI(t[c]);null!=e.key&&_.set(e.key,c)}let y=0,x=d-g+1,b=!1,O=0,w=Array(x);for(c=0;c<x;c++)w[c]=0;for(c=m;c<=f;c++){let r;let u=e[c];if(y>=x){eu(u,l,o,!0);continue}if(null!=u.key)r=_.get(u.key);else for(h=g;h<=d;h++)if(0===w[h-g]&&tP(u,t[h])){r=h;break}void 0===r?eu(u,l,o,!0):(w[r-g]=c+1,r>=O?O=r:b=!0,S(u,t[r],n,null,l,o,i,s,a),y++)}let T=b?function(e){let t,n,r,l,o;let i=e.slice(),s=[0],a=e.length;for(t=0;t<a;t++){let a=e[t];if(0!==a){if(e[n=s[s.length-1]]<a){i[t]=n,s.push(t);continue}for(r=0,l=s.length-1;r<l;)e[s[o=r+l>>1]]<a?r=o+1:l=o;a<e[s[r]]&&(r>0&&(i[t]=s[r-1]),s[r]=t)}}for(r=s.length,l=s[r-1];r-- >0;)s[r]=l,l=i[l];return s}(w):u.EMPTY_ARR;for(h=T.length-1,c=x-1;c>=0;c--){let e=g+c,u=t[e],f=e+1<p?t[e+1].el:r;0===w[c]?S(null,u,n,f,l,o,i,s,a):b&&(h<0||c!==T[h]?ea(u,n,f,2):h--)}}},ea=(e,t,n,r,l=null)=>{let{el:o,type:i,transition:a,children:u,shapeFlag:c}=e;if(6&c){ea(e.component.subTree,t,n,r);return}if(128&c){e.suspense.move(t,n,r);return}if(64&c){i.move(e,t,n,eg);return}if(i===t_){s(o,t,n);for(let e=0;e<u.length;e++)ea(u[e],t,n,r);s(e.anchor,t,n);return}if(i===tb){B(e,t,n);return}let p=2!==r&&1&c&&a;if(p){if(0===r)a.beforeEnter(o),s(o,t,n),tf(()=>a.enter(o),l);else{let{leave:e,delayLeave:r,afterLeave:l}=a,i=()=>s(o,t,n),u=()=>{e(o,()=>{i(),l&&l()})};r?r(o,i,u):u()}}else s(o,t,n)},eu=(e,t,n,r=!1,l=!1)=>{let o;let{type:i,props:s,ref:a,children:u,dynamicChildren:c,shapeFlag:p,patchFlag:f,dirs:d}=e;if(null!=a&&ts(a,null,n,e,!0),256&p){t.ctx.deactivate(e);return}let h=1&p&&d,m=!e_(e);if(m&&(o=s&&s.onVnodeBeforeUnmount)&&tU(o,t,e),6&p)ef(e.component,n,r);else{if(128&p){e.suspense.unmount(n,r);return}h&&ei(e,null,t,"beforeUnmount"),64&p?e.type.remove(e,t,n,l,eg,r):c&&// #1153: fast path should not be taken for non-stable (v-for) fragments
(i!==t_||f>0&&64&f)?ed(c,t,n,!1,!0):(i===t_&&384&f||!l&&16&p)&&ed(u,t,n),r&&ec(e)}(m&&(o=s&&s.onVnodeUnmounted)||h)&&tf(()=>{o&&tU(o,t,e),h&&ei(e,null,t,"unmounted")},n)},ec=e=>{let{type:t,el:n,anchor:r,transition:l}=e;if(t===t_){ep(n,r);return}if(t===tb){$(e);return}let o=()=>{c(n),l&&!l.persisted&&l.afterLeave&&l.afterLeave()};if(1&e.shapeFlag&&l&&!l.persisted){let{leave:t,delayLeave:r}=l,i=()=>t(n,o);r?r(e.el,o,i):i()}else o()},ep=(e,t)=>{let n;for(;e!==t;)n=w(e),c(e),e=n;c(t)},ef=(e,t,n)=>{let{bum:r,scope:l,update:o,subTree:i,um:s}=e;r&&(0,u.invokeArrayFns)(r),l.stop(),o&&(o.active=!1,eu(i,e,t,n)),s&&tf(s,t),tf(()=>{e.isUnmounted=!0},t),t&&t.pendingBranch&&!t.isUnmounted&&e.asyncDep&&!e.asyncResolved&&e.suspenseId===t.pendingId&&(t.deps--,0===t.deps&&t.resolve()),__VUE_PROD_DEVTOOLS__&&I(e)},ed=(e,t,n,r=!1,l=!1,o=0)=>{for(let i=o;i<e.length;i++)eu(e[i],t,n,r,l)},eh=e=>6&e.shapeFlag?eh(e.component.subTree):128&e.shapeFlag?e.suspense.next():w(e.anchor||e.el),em=(e,t,n)=>{null==e?t._vnode&&eu(t._vnode,null,null,!0):S(t._vnode||null,e,t,null,null,null,n),k(),P(),t._vnode=e},eg={p:S,um:eu,m:ea,r:ec,mt:ee,mc:Y,pc:el,pbc:q,n:eh,o:e};return t&&([l,o]=t(eg)),{render:em,hydrate:l,createApp:(r=l,function(e,t=null){(0,u.isFunction)(e)||(e=(0,u.extend)({},e)),null==t||(0,u.isObject)(t)||(t=null);let n=e1(),l=/* @__PURE__ */new Set,o=!1,i=n.app={_uid:e2++,_component:e,_props:t,_container:null,_context:n,_instance:null,version:t6,get config(){return n.config},set config(v){},use:(e,...t)=>(l.has(e)||(e&&(0,u.isFunction)(e.install)?(l.add(e),e.install(i,...t)):(0,u.isFunction)(e)&&(l.add(e),e(i,...t))),i),mixin:e=>(__VUE_OPTIONS_API__&&!n.mixins.includes(e)&&n.mixins.push(e),i),component:(e,t)=>t?(n.components[e]=t,i):n.components[e],directive:(e,t)=>t?(n.directives[e]=t,i):n.directives[e],mount(l,s,a){if(!o){let u=tN(e,t);return u.appContext=n,s&&r?r(u,l):em(u,l,a),o=!0,i._container=l,l.__vue_app__=i,__VUE_PROD_DEVTOOLS__&&(i._instance=u.component,N("app:init"/* APP_INIT */,i,t6,{Fragment:t_,Text:ty,Comment:tx,Static:tb})),t0(u.component)||u.component.proxy}},unmount(){o&&(em(null,i._container),__VUE_PROD_DEVTOOLS__&&(i._instance=null,N("app:unmount"/* APP_UNMOUNT */,i)),delete i._container.__vue_app__)},provide:(e,t)=>(n.provides[e]=t,i),runWithContext(e){e8=i;try{return e()}finally{e8=null}}};return i})}}function tg({effect:e,update:t},n){e.allowRecurse=t.allowRecurse=n}let tv=e=>e.__isTeleport,t_=Symbol.for("v-fgt"),ty=Symbol.for("v-txt"),tx=Symbol.for("v-cmt"),tb=Symbol.for("v-stc"),tO=[],tw=null;function tT(e=!1){tO.push(tw=e?null:[])}let tE=1;function tC(e){return e.dynamicChildren=tE>0?tw||u.EMPTY_ARR:null,tO.pop(),tw=tO[tO.length-1]||null,tE>0&&tw&&tw.push(e),e}function tS(e,t,n,r,l,o){return tC(tF(e,t,n,r,l,o,!0))}function tk(e){return!!e&&!0===e.__v_isVNode}function tP(e,t){return e.type===t.type&&e.key===t.key}let tR="__vInternal",tA=({key:e})=>null!=e?e:null,tV=({ref:e,ref_key:t,ref_for:n})=>("number"==typeof e&&(e=""+e),null!=e?(0,u.isString)(e)||(0,a.isRef)(e)||(0,u.isFunction)(e)?{i:$,r:e,k:t,f:!!n}:e:null);function tF(e,t=null,n=null,r=0,l=null,o=e===t_?0:1,i=!1,s=!1){let a={__v_isVNode:!0,__v_skip:!0,type:e,props:t,key:t&&tA(t),ref:t&&tV(t),scopeId:Q,slotScopeIds:null,children:n,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetAnchor:null,staticCount:0,shapeFlag:o,patchFlag:r,dynamicProps:l,dynamicChildren:null,appContext:null,ctx:$};return s?(tD(a,n),128&o&&e.normalize(a)):n&&(a.shapeFlag|=(0,u.isString)(n)?8:16),tE>0&&// avoid a block node from tracking itself
!i&&// has current parent block
tw&&// presence of a patch flag indicates this node needs patching on updates.
// component nodes also should always be patched, because even if the
// component doesn't need to update, it needs to persist the instance on to
// the next vnode so that it can be properly unmounted later.
(a.patchFlag>0||6&o)&&// the EVENTS flag is only for hydration and if it is the only flag, the
// vnode should not be considered dynamic due to handler caching.
32!==a.patchFlag&&tw.push(a),a}let tN=function(e,t=null,n=null,r=0,l=null,o=!1){var i,s;if(e&&e!==ej||(e=tx),tk(e)){let r=tL(e,t,!0);return n&&tD(r,n),tE>0&&!o&&tw&&(6&r.shapeFlag?tw[tw.indexOf(e)]=r:tw.push(r)),r.patchFlag|=-2,r}if(i=e,(0,u.isFunction)(i)&&"__vccOpts"in i&&(e=e.__vccOpts),t){let{class:e,style:n}=t=(s=t)?(0,a.isProxy)(s)||tR in s?(0,u.extend)({},s):s:null;e&&!(0,u.isString)(e)&&(t.class=(0,u.normalizeClass)(e)),(0,u.isObject)(n)&&((0,a.isProxy)(n)&&!(0,u.isArray)(n)&&(n=(0,u.extend)({},n)),t.style=(0,u.normalizeStyle)(n))}let c=(0,u.isString)(e)?1:q(e)?128:tv(e)?64:(0,u.isObject)(e)?4:(0,u.isFunction)(e)?2:0;return tF(e,t,n,r,l,c,o,!0)};function tL(e,t,n=!1){let{props:r,ref:l,patchFlag:o,children:i}=e,s=t?function(...e){let t={};for(let n=0;n<e.length;n++){let r=e[n];for(let e in r)if("class"===e)t.class!==r.class&&(t.class=(0,u.normalizeClass)([t.class,r.class]));else if("style"===e)t.style=(0,u.normalizeStyle)([t.style,r.style]);else if((0,u.isOn)(e)){let n=t[e],l=r[e];l&&n!==l&&!((0,u.isArray)(n)&&n.includes(l))&&(t[e]=n?[].concat(n,l):l)}else""!==e&&(t[e]=r[e])}return t}(r||{},t):r,a={__v_isVNode:!0,__v_skip:!0,type:e.type,props:s,key:s&&tA(s),ref:t&&t.ref?// if the vnode itself already has a ref, cloneVNode will need to merge
// the refs so the single vnode can be set on multiple refs
n&&l?(0,u.isArray)(l)?l.concat(tV(t)):[l,tV(t)]:tV(t):l,scopeId:e.scopeId,slotScopeIds:e.slotScopeIds,children:i,target:e.target,targetAnchor:e.targetAnchor,staticCount:e.staticCount,shapeFlag:e.shapeFlag,// if the vnode is cloned with extra props, we can no longer assume its
// existing patch flag to be reliable and need to add the FULL_PROPS flag.
// note: preserve flag for fragments since they use the flag for children
// fast paths only.
patchFlag:t&&e.type!==t_?-1===o?16:16|o:o,dynamicProps:e.dynamicProps,dynamicChildren:e.dynamicChildren,appContext:e.appContext,dirs:e.dirs,transition:e.transition,// These should technically only be non-null on mounted VNodes. However,
// they *should* be copied for kept-alive vnodes. So we just always copy
// them since them being non-null during a mount doesn't affect the logic as
// they will simply be overwritten.
component:e.component,suspense:e.suspense,ssContent:e.ssContent&&tL(e.ssContent),ssFallback:e.ssFallback&&tL(e.ssFallback),el:e.el,anchor:e.anchor,ctx:e.ctx,ce:e.ce};return a}function tM(e=" ",t=0){return tN(ty,null,e,t)}function tj(e="",t=!1){return t?(tT(),tC(tN(tx,null,e,void 0,void 0,!0))):tN(tx,null,e)}function tI(e){return null==e||"boolean"==typeof e?tN(tx):(0,u.isArray)(e)?tN(t_,null,e.slice()):"object"==typeof e?tB(e):tN(ty,null,String(e))}function tB(e){return null===e.el&&-1!==e.patchFlag||e.memo?e:tL(e)}function tD(e,t){let n=0,{shapeFlag:r}=e;if(null==t)t=null;else if((0,u.isArray)(t))n=16;else if("object"==typeof t){if(65&r){let n=t.default;n&&(n._c&&(n._d=!1),tD(e,n()),n._c&&(n._d=!0));return}{n=32;let r=t._;r||tR in t?3===r&&$&&(1===$.slots._?t._=1:(t._=2,e.patchFlag|=1024)):t._ctx=$}}else(0,u.isFunction)(t)?(t={default:t,_ctx:$},n=32):(t=String(t),64&r?(n=16,t=[tM(t)]):n=8);e.children=t,e.shapeFlag|=n}function tU(e,t,n,r=null){f(e,t,7,[n,r])}let t$=e1(),tQ=0,tW=null,tH=()=>tW||$,tz="__VUE_INSTANCE_SETTERS__";(o=(0,u.getGlobalThis)()[tz])||(o=(0,u.getGlobalThis)()[tz]=[]),o.push(e=>tW=e),r=e=>{o.length>1?o.forEach(t=>t(e)):o[0](e)};let tY=e=>{r(e),e.scope.on()},tJ=()=>{tW&&tW.scope.off(),r(null)};function tG(e){return 4&e.vnode.shapeFlag}let tq=!1;function tK(e,t,n){(0,u.isFunction)(t)?e.type.__ssrInlineRender?e.ssrRender=t:e.render=t:(0,u.isObject)(t)&&(__VUE_PROD_DEVTOOLS__&&(e.devtoolsRawSetupState=t),e.setupState=(0,a.proxyRefs)(t)),tZ(e,n)}let tX=()=>!i;function tZ(e,t,n){let r=e.type;if(!e.render){if(!t&&i&&!r.render){let t=r.template||eY(e).template;if(t){let{isCustomElement:n,compilerOptions:l}=e.appContext.config,{delimiters:o,compilerOptions:s}=r,a=(0,u.extend)((0,u.extend)({isCustomElement:n,delimiters:o},l),s);r.render=i(t,a)}}e.render=r.render||u.NOOP,s&&s(e)}__VUE_OPTIONS_API__&&(tY(e),(0,a.pauseTracking)(),function(e){let t=eY(e),n=e.proxy,r=e.ctx;eH=!1,t.beforeCreate&&ez(t.beforeCreate,e,"bc");let{data:l,computed:o,methods:i,watch:s,provide:c,inject:p,created:f,beforeMount:d,mounted:h,beforeUpdate:m,updated:g,activated:_,deactivated:y,beforeDestroy:x,beforeUnmount:b,destroyed:O,unmounted:w,render:T,renderTracked:E,renderTriggered:C,errorCaptured:S,serverPrefetch:k,expose:P,inheritAttrs:R,components:A,directives:V,filters:F}=t;if(p&&function(e,t,n=u.NOOP){for(let n in(0,u.isArray)(e)&&(e=eK(e)),e){let r;let l=e[n];r=(0,u.isObject)(l)?"default"in l?e4(l.from||n,l.default,!0):e4(l.from||n):e4(l),(0,a.isRef)(r)?Object.defineProperty(t,n,{enumerable:!0,configurable:!0,get:()=>r.value,set:e=>r.value=e}):t[n]=r}}(p,r,null),i)for(let e in i){let t=i[e];(0,u.isFunction)(t)&&(r[e]=t.bind(n))}if(l){let t=l.call(n,n);(0,u.isObject)(t)&&(e.data=(0,a.reactive)(t))}if(eH=!0,o)for(let e in o){let t=o[e],l=(0,u.isFunction)(t)?t.bind(n,n):(0,u.isFunction)(t.get)?t.get.bind(n,n):u.NOOP,i=!(0,u.isFunction)(t)&&(0,u.isFunction)(t.set)?t.set.bind(n):u.NOOP,s=t1({get:l,set:i});Object.defineProperty(r,e,{enumerable:!0,configurable:!0,get:()=>s.value,set:e=>s.value=e})}if(s)for(let e in s)(function e(t,n,r,l){let o=l.includes(".")?el(r,l):()=>r[l];if((0,u.isString)(t)){let e=n[t];(0,u.isFunction)(e)&&en(o,e,void 0)}else if((0,u.isFunction)(t))en(o,t.bind(r),void 0);else if((0,u.isObject)(t)){if((0,u.isArray)(t))t.forEach(t=>e(t,n,r,l));else{let e=(0,u.isFunction)(t.handler)?t.handler.bind(r):n[t.handler];(0,u.isFunction)(e)&&en(o,e,t)}}})(s[e],r,n,e);if(c){let e=(0,u.isFunction)(c)?c.call(n):c;Reflect.ownKeys(e).forEach(t=>{e3(t,e[t])})}function N(e,t){(0,u.isArray)(t)?t.forEach(t=>e(t.bind(n))):t&&e(t.bind(n))}if(f&&ez(f,e,"c"),N(eE,d),N(eC,h),N(eS,m),N(ek,g),N(ex,_),N(eb,y),N(eN,S),N(eF,E),N(eV,C),N(eP,b),N(eR,w),N(eA,k),(0,u.isArray)(P)){if(P.length){let t=e.exposed||(e.exposed={});P.forEach(e=>{Object.defineProperty(t,e,{get:()=>n[e],set:t=>n[e]=t})})}else e.exposed||(e.exposed={})}T&&e.render===u.NOOP&&(e.render=T),null!=R&&(e.inheritAttrs=R),A&&(e.components=A),V&&(e.directives=V)}(e),(0,a.resetTracking)(),tJ())}function t0(e){if(e.exposed)return e.exposeProxy||(e.exposeProxy=new Proxy((0,a.proxyRefs)((0,a.markRaw)(e.exposed)),{get:(t,n)=>n in t?t[n]:n in eU?eU[n](e):void 0,has:(e,t)=>t in e||t in eU}))}let t1=(e,t)=>(0,a.computed)(e,t,tq);function t2(e,t,n){let r=arguments.length;return 2!==r?(r>3?n=Array.prototype.slice.call(arguments,2):3===r&&tk(n)&&(n=[n]),tN(e,t,n)):!(0,u.isObject)(t)||(0,u.isArray)(t)?tN(e,null,t):tk(t)?tN(e,null,[t]):tN(e,t)}let t8=Symbol.for("v-scx"),t3=()=>{{let e=e4(t8);return e}};function t4(){}let t6="3.3.4"}),h.register("01W3b",function(e,t){let n,r;l(e.exports,"EffectScope",()=>i),l(e.exports,"getCurrentScope",()=>s),l(e.exports,"ReactiveEffect",()=>x),l(e.exports,"pauseTracking",()=>T),l(e.exports,"resetTracking",()=>E),l(e.exports,"track",()=>C),l(e.exports,"trigger",()=>k),l(e.exports,"toRaw",()=>ew),l(e.exports,"isRef",()=>eP),l(e.exports,"reactive",()=>em),l(e.exports,"isShallow",()=>eb),l(e.exports,"shallowReactive",()=>eg),l(e.exports,"isReactive",()=>ey),l(e.exports,"isProxy",()=>eO),l(e.exports,"markRaw",()=>eT),l(e.exports,"ref",()=>eR),l(e.exports,"shallowRef",()=>eA),l(e.exports,"unref",()=>eN),l(e.exports,"proxyRefs",()=>eM),l(e.exports,"computed",()=>eI);var o=h("8POXm");class i{constructor(e=!1){this.detached=e,/**
     * @internal
     */this._active=!0,/**
     * @internal
     */this.effects=[],/**
     * @internal
     */this.cleanups=[],this.parent=n,!e&&n&&(this.index=(n.scopes||(n.scopes=[])).push(this)-1)}get active(){return this._active}run(e){if(this._active){let t=n;try{return n=this,e()}finally{n=t}}}/**
   * This should only be called on non-detached scopes
   * @internal
   */on(){n=this}/**
   * This should only be called on non-detached scopes
   * @internal
   */off(){n=this.parent}stop(e){if(this._active){let t,n;for(t=0,n=this.effects.length;t<n;t++)this.effects[t].stop();for(t=0,n=this.cleanups.length;t<n;t++)this.cleanups[t]();if(this.scopes)for(t=0,n=this.scopes.length;t<n;t++)this.scopes[t].stop(!0);if(!this.detached&&this.parent&&!e){let e=this.parent.scopes.pop();e&&e!==this&&(this.parent.scopes[this.index]=e,e.index=this.index)}this.parent=void 0,this._active=!1}}}function s(){return n}let a=e=>{let t=new Set(e);return t.w=0,t.n=0,t},u=e=>(e.w&g)>0,c=e=>(e.n&g)>0,p=({deps:e})=>{if(e.length)for(let t=0;t<e.length;t++)e[t].w|=g},f=e=>{let{deps:t}=e;if(t.length){let n=0;for(let r=0;r<t.length;r++){let l=t[r];u(l)&&!c(l)?l.delete(e):t[n++]=l,l.w&=~g,l.n&=~g}t.length=n}},d=/* @__PURE__ */new WeakMap,m=0,g=1,_=Symbol(""),y=Symbol("");class x{constructor(e,t=null,r){this.fn=e,this.scheduler=t,this.active=!0,this.deps=[],this.parent=void 0,function(e,t=n){t&&t.active&&t.effects.push(e)}(this,r)}run(){if(!this.active)return this.fn();let e=r,t=O;for(;e;){if(e===this)return;e=e.parent}try{return this.parent=r,r=this,O=!0,g=1<<++m,m<=30?p(this):b(this),this.fn()}finally{m<=30&&f(this),g=1<<--m,r=this.parent,O=t,this.parent=void 0,this.deferStop&&this.stop()}}stop(){r===this?this.deferStop=!0:this.active&&(b(this),this.onStop&&this.onStop(),this.active=!1)}}function b(e){let{deps:t}=e;if(t.length){for(let n=0;n<t.length;n++)t[n].delete(e);t.length=0}}let O=!0,w=[];function T(){w.push(O),O=!1}function E(){let e=w.pop();O=void 0===e||e}function C(e,t,n){if(O&&r){let t=d.get(e);t||d.set(e,t=/* @__PURE__ */new Map);let r=t.get(n);r||t.set(n,r=a()),S(r,void 0)}}function S(e,t){let n=!1;m<=30?c(e)||(e.n|=g,n=!u(e)):n=!e.has(r),n&&(e.add(r),r.deps.push(e))}function k(e,t,n,r,l,i){let s=d.get(e);if(!s)return;let u=[];if("clear"===t)u=[...s.values()];else if("length"===n&&(0,o.isArray)(e)){let e=Number(r);s.forEach((t,n)=>{("length"===n||n>=e)&&u.push(t)})}else switch(void 0!==n&&u.push(s.get(n)),t){case"add":(0,o.isArray)(e)?(0,o.isIntegerKey)(n)&&u.push(s.get("length")):(u.push(s.get(_)),(0,o.isMap)(e)&&u.push(s.get(y)));break;case"delete":!(0,o.isArray)(e)&&(u.push(s.get(_)),(0,o.isMap)(e)&&u.push(s.get(y)));break;case"set":(0,o.isMap)(e)&&u.push(s.get(_))}if(1===u.length)u[0]&&P(u[0]);else{let e=[];for(let t of u)t&&e.push(...t);P(a(e))}}function P(e,t){let n=(0,o.isArray)(e)?e:[...e];for(let e of n)e.computed&&R(e,t);for(let e of n)e.computed||R(e,t)}function R(e,t){(e!==r||e.allowRecurse)&&(e.scheduler?e.scheduler():e.run())}let A=/* @__PURE__ */(0,o.makeMap)("__proto__,__v_isRef,__isVue"),V=new Set(/* @__PURE__ */Object.getOwnPropertyNames(Symbol).filter(e=>"arguments"!==e&&"caller"!==e).map(e=>Symbol[e]).filter(o.isSymbol)),F=/* @__PURE__ */I(),N=/* @__PURE__ */I(!1,!0),L=/* @__PURE__ */I(!0),M=/* @__PURE__ */function(){let e={};return["includes","indexOf","lastIndexOf"].forEach(t=>{e[t]=function(...e){let n=ew(this);for(let e=0,t=this.length;e<t;e++)C(n,"get",e+"");let r=n[t](...e);return -1===r||!1===r?n[t](...e.map(ew)):r}}),["push","pop","shift","unshift","splice"].forEach(t=>{e[t]=function(...e){T();let n=ew(this)[t].apply(this,e);return E(),n}}),e}();function j(e){let t=ew(this);return C(t,"has",e),t.hasOwnProperty(e)}function I(e=!1,t=!1){return function(n,r,l){if("__v_isReactive"===r)return!e;if("__v_isReadonly"===r)return e;if("__v_isShallow"===r)return t;if("__v_raw"===r&&l===(e?t?eh:ed:t?ef:ep).get(n))return n;let i=(0,o.isArray)(n);if(!e){if(i&&(0,o.hasOwn)(M,r))return Reflect.get(M,r,l);if("hasOwnProperty"===r)return j}let s=Reflect.get(n,r,l);return((0,o.isSymbol)(r)?V.has(r):A(r))?s:(e||C(n,"get",r),t)?s:eP(s)?i&&(0,o.isIntegerKey)(r)?s:s.value:(0,o.isObject)(s)?e?ev(s):em(s):s}}let B=/* @__PURE__ */U(),D=/* @__PURE__ */U(!0);function U(e=!1){return function(t,n,r,l){let i=t[n];if(ex(i)&&eP(i)&&!eP(r))return!1;if(!e&&(eb(r)||ex(r)||(i=ew(i),r=ew(r)),!(0,o.isArray)(t)&&eP(i)&&!eP(r)))return i.value=r,!0;let s=(0,o.isArray)(t)&&(0,o.isIntegerKey)(n)?Number(n)<t.length:(0,o.hasOwn)(t,n),a=Reflect.set(t,n,r,l);return t===ew(l)&&(s?(0,o.hasChanged)(r,i)&&k(t,"set",n,r,i):k(t,"add",n,r)),a}}let $={get:F,set:B,deleteProperty:function(e,t){let n=(0,o.hasOwn)(e,t),r=e[t],l=Reflect.deleteProperty(e,t);return l&&n&&k(e,"delete",t,void 0,r),l},has:function(e,t){let n=Reflect.has(e,t);return(0,o.isSymbol)(t)&&V.has(t)||C(e,"has",t),n},ownKeys:function(e){return C(e,"iterate",(0,o.isArray)(e)?"length":_),Reflect.ownKeys(e)}},Q={get:L,set:(e,t)=>!0,deleteProperty:(e,t)=>!0},W=/* @__PURE__ */(0,o.extend)({},$,{get:N,set:D}),H=e=>e,z=e=>Reflect.getPrototypeOf(e);function Y(e,t,n=!1,r=!1){e=e.__v_raw;let l=ew(e),o=ew(t);n||(t!==o&&C(l,"get",t),C(l,"get",o));let{has:i}=z(l),s=r?H:n?eC:eE;return i.call(l,t)?s(e.get(t)):i.call(l,o)?s(e.get(o)):void(e!==l&&e.get(t))}function J(e,t=!1){let n=this.__v_raw,r=ew(n),l=ew(e);return t||(e!==l&&C(r,"has",e),C(r,"has",l)),e===l?n.has(e):n.has(e)||n.has(l)}function G(e,t=!1){return e=e.__v_raw,t||C(ew(e),"iterate",_),Reflect.get(e,"size",e)}function q(e){e=ew(e);let t=ew(this),n=z(t),r=n.has.call(t,e);return r||(t.add(e),k(t,"add",e,e)),this}function K(e,t){t=ew(t);let n=ew(this),{has:r,get:l}=z(n),i=r.call(n,e);i||(e=ew(e),i=r.call(n,e));let s=l.call(n,e);return n.set(e,t),i?(0,o.hasChanged)(t,s)&&k(n,"set",e,t,s):k(n,"add",e,t),this}function X(e){let t=ew(this),{has:n,get:r}=z(t),l=n.call(t,e);l||(e=ew(e),l=n.call(t,e));let o=r?r.call(t,e):void 0,i=t.delete(e);return l&&k(t,"delete",e,void 0,o),i}function Z(){let e=ew(this),t=0!==e.size,n=e.clear();return t&&k(e,"clear",void 0,void 0,void 0),n}function ee(e,t){return function(n,r){let l=this,o=l.__v_raw,i=ew(o),s=t?H:e?eC:eE;return e||C(i,"iterate",_),o.forEach((e,t)=>n.call(r,s(e),s(t),l))}}function et(e,t,n){return function(...r){let l=this.__v_raw,i=ew(l),s=(0,o.isMap)(i),a="entries"===e||e===Symbol.iterator&&s,u="keys"===e&&s,c=l[e](...r),p=n?H:t?eC:eE;return t||C(i,"iterate",u?y:_),{// iterator protocol
next(){let{value:e,done:t}=c.next();return t?{value:e,done:t}:{value:a?[p(e[0]),p(e[1])]:p(e),done:t}},// iterable protocol
[Symbol.iterator](){return this}}}}function en(e){return function(...t){return"delete"!==e&&this}}let[er,el,eo,ei]=/* @__PURE__ */function(){let e={get(e){return Y(this,e)},get size(){return G(this)},has:J,add:q,set:K,delete:X,clear:Z,forEach:ee(!1,!1)},t={get(e){return Y(this,e,!1,!0)},get size(){return G(this)},has:J,add:q,set:K,delete:X,clear:Z,forEach:ee(!1,!0)},n={get(e){return Y(this,e,!0)},get size(){return G(this,!0)},has(e){return J.call(this,e,!0)},add:en("add"),set:en("set"),delete:en("delete"),clear:en("clear"),forEach:ee(!0,!1)},r={get(e){return Y(this,e,!0,!0)},get size(){return G(this,!0)},has(e){return J.call(this,e,!0)},add:en("add"),set:en("set"),delete:en("delete"),clear:en("clear"),forEach:ee(!0,!0)},l=["keys","values","entries",Symbol.iterator];return l.forEach(l=>{e[l]=et(l,!1,!1),n[l]=et(l,!0,!1),t[l]=et(l,!1,!0),r[l]=et(l,!0,!0)}),[e,n,t,r]}();function es(e,t){let n=t?e?ei:eo:e?el:er;return(t,r,l)=>"__v_isReactive"===r?!e:"__v_isReadonly"===r?e:"__v_raw"===r?t:Reflect.get((0,o.hasOwn)(n,r)&&r in t?n:t,r,l)}let ea={get:/* @__PURE__ */es(!1,!1)},eu={get:/* @__PURE__ */es(!1,!0)},ec={get:/* @__PURE__ */es(!0,!1)},ep=/* @__PURE__ */new WeakMap,ef=/* @__PURE__ */new WeakMap,ed=/* @__PURE__ */new WeakMap,eh=/* @__PURE__ */new WeakMap;function em(e){return ex(e)?e:e_(e,!1,$,ea,ep)}function eg(e){return e_(e,!1,W,eu,ef)}function ev(e){return e_(e,!0,Q,ec,ed)}function e_(e,t,n,r,l){if(!(0,o.isObject)(e)||e.__v_raw&&!(t&&e.__v_isReactive))return e;let i=l.get(e);if(i)return i;let s=e.__v_skip||!Object.isExtensible(e)?0/* INVALID */:function(e){switch(e){case"Object":case"Array":return 1/* COMMON */;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2/* COLLECTION */;default:return 0/* INVALID */}}((0,o.toRawType)(e));if(0/* INVALID */===s)return e;let a=new Proxy(e,2/* COLLECTION */===s?r:n);return l.set(e,a),a}function ey(e){return ex(e)?ey(e.__v_raw):!!(e&&e.__v_isReactive)}function ex(e){return!!(e&&e.__v_isReadonly)}function eb(e){return!!(e&&e.__v_isShallow)}function eO(e){return ey(e)||ex(e)}function ew(e){let t=e&&e.__v_raw;return t?ew(t):e}function eT(e){return(0,o.def)(e,"__v_skip",!0),e}let eE=e=>(0,o.isObject)(e)?em(e):e,eC=e=>(0,o.isObject)(e)?ev(e):e;function eS(e){O&&r&&S((e=ew(e)).dep||(e.dep=a()))}function ek(e,t){e=ew(e);let n=e.dep;n&&P(n)}function eP(e){return!!(e&&!0===e.__v_isRef)}function eR(e){return eV(e,!1)}function eA(e){return eV(e,!0)}function eV(e,t){return eP(e)?e:new eF(e,t)}class eF{constructor(e,t){this.__v_isShallow=t,this.dep=void 0,this.__v_isRef=!0,this._rawValue=t?e:ew(e),this._value=t?e:eE(e)}get value(){return eS(this),this._value}set value(e){let t=this.__v_isShallow||eb(e)||ex(e);e=t?e:ew(e),(0,o.hasChanged)(e,this._rawValue)&&(this._rawValue=e,this._value=t?e:eE(e),ek(this,e))}}function eN(e){return eP(e)?e.value:e}let eL={get:(e,t,n)=>eN(Reflect.get(e,t,n)),set:(e,t,n,r)=>{let l=e[t];return eP(l)&&!eP(n)?(l.value=n,!0):Reflect.set(e,t,n,r)}};function eM(e){return ey(e)?e:new Proxy(e,eL)}class ej{constructor(e,t,n,r){this._setter=t,this.dep=void 0,this.__v_isRef=!0,this.__v_isReadonly=!1,this._dirty=!0,this.effect=new x(e,()=>{this._dirty||(this._dirty=!0,ek(this))}),this.effect.computed=this,this.effect.active=this._cacheable=!r,this.__v_isReadonly=n}get value(){let e=ew(this);return eS(e),(e._dirty||!e._cacheable)&&(e._dirty=!1,e._value=e.effect.run()),e._value}set value(e){this._setter(e)}}function eI(e,t,n=!1){let r,l;let i=(0,o.isFunction)(e);i?(r=e,l=o.NOOP):(r=e.get,l=e.set);let s=new ej(r,l,i||!l,n);return s}}),h.register("8POXm",function(e,t){let n;function r(e,t){let n=/* @__PURE__ */Object.create(null),r=e.split(",");for(let e=0;e<r.length;e++)n[r[e]]=!0;return t?e=>!!n[e.toLowerCase()]:e=>!!n[e]}l(e.exports,"makeMap",()=>r),l(e.exports,"EMPTY_OBJ",()=>o),l(e.exports,"EMPTY_ARR",()=>i),l(e.exports,"NOOP",()=>s),l(e.exports,"NO",()=>a),l(e.exports,"isOn",()=>c),l(e.exports,"isModelListener",()=>f),l(e.exports,"extend",()=>d),l(e.exports,"remove",()=>h),l(e.exports,"hasOwn",()=>g),l(e.exports,"isArray",()=>_),l(e.exports,"isMap",()=>y),l(e.exports,"isSet",()=>x),l(e.exports,"isRegExp",()=>O),l(e.exports,"isFunction",()=>w),l(e.exports,"isString",()=>T),l(e.exports,"isSymbol",()=>E),l(e.exports,"isObject",()=>C),l(e.exports,"isPromise",()=>S),l(e.exports,"toRawType",()=>R),l(e.exports,"isPlainObject",()=>A),l(e.exports,"isIntegerKey",()=>V),l(e.exports,"isReservedProp",()=>F),l(e.exports,"isBuiltInDirective",()=>N),l(e.exports,"camelize",()=>j),l(e.exports,"hyphenate",()=>B),l(e.exports,"capitalize",()=>D),l(e.exports,"toHandlerKey",()=>U),l(e.exports,"hasChanged",()=>$),l(e.exports,"invokeArrayFns",()=>Q),l(e.exports,"def",()=>W),l(e.exports,"looseToNumber",()=>H),l(e.exports,"toNumber",()=>z),l(e.exports,"getGlobalThis",()=>Y),l(e.exports,"isGloballyWhitelisted",()=>J),l(e.exports,"normalizeStyle",()=>function e(t){if(_(t)){let n={};for(let r=0;r<t.length;r++){let l=t[r],o=T(l)?function(e){let t={};return e.replace(K,"").split(G).forEach(e=>{if(e){let n=e.split(q);n.length>1&&(t[n[0].trim()]=n[1].trim())}}),t}(l):e(l);if(o)for(let e in o)n[e]=o[e]}return n}if(T(t)||C(t))return t}),l(e.exports,"normalizeClass",()=>function e(t){let n="";if(T(t))n=t;else if(_(t))for(let r=0;r<t.length;r++){let l=e(t[r]);l&&(n+=l+" ")}else if(C(t))for(let e in t)t[e]&&(n+=e+" ");return n.trim()}),l(e.exports,"isHTMLTag",()=>X),l(e.exports,"isSVGTag",()=>Z),l(e.exports,"isSpecialBooleanAttr",()=>ee),l(e.exports,"includeBooleanAttr",()=>et),l(e.exports,"looseEqual",()=>en),l(e.exports,"looseIndexOf",()=>er),l(e.exports,"toDisplayString",()=>el);let o={},i=[],s=()=>{},a=()=>!1,u=/^on[^a-z]/,c=e=>u.test(e),f=e=>e.startsWith("onUpdate:"),d=Object.assign,h=(e,t)=>{let n=e.indexOf(t);n>-1&&e.splice(n,1)},m=Object.prototype.hasOwnProperty,g=(e,t)=>m.call(e,t),_=Array.isArray,y=e=>"[object Map]"===P(e),x=e=>"[object Set]"===P(e),b=e=>"[object Date]"===P(e),O=e=>"[object RegExp]"===P(e),w=e=>"function"==typeof e,T=e=>"string"==typeof e,E=e=>"symbol"==typeof e,C=e=>null!==e&&"object"==typeof e,S=e=>C(e)&&w(e.then)&&w(e.catch),k=Object.prototype.toString,P=e=>k.call(e),R=e=>P(e).slice(8,-1),A=e=>"[object Object]"===P(e),V=e=>T(e)&&"NaN"!==e&&"-"!==e[0]&&""+parseInt(e,10)===e,F=/* @__PURE__ */r(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),N=/* @__PURE__ */r("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"),L=e=>{let t=/* @__PURE__ */Object.create(null);return n=>{let r=t[n];return r||(t[n]=e(n))}},M=/-(\w)/g,j=L(e=>e.replace(M,(e,t)=>t?t.toUpperCase():"")),I=/\B([A-Z])/g,B=L(e=>e.replace(I,"-$1").toLowerCase()),D=L(e=>e.charAt(0).toUpperCase()+e.slice(1)),U=L(e=>e?`on${D(e)}`:""),$=(e,t)=>!Object.is(e,t),Q=(e,t)=>{for(let n=0;n<e.length;n++)e[n](t)},W=(e,t,n)=>{Object.defineProperty(e,t,{configurable:!0,enumerable:!1,value:n})},H=e=>{let t=parseFloat(e);return isNaN(t)?e:t},z=e=>{let t=T(e)?Number(e):NaN;return isNaN(t)?e:t},Y=()=>n||(n="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:void 0!==p?p:{}),J=/* @__PURE__ */r("Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console"),G=/;(?![^(]*\))/g,q=/:([^]+)/,K=/\/\*[^]*?\*\//g,X=/* @__PURE__ */r("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot"),Z=/* @__PURE__ */r("svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view"),ee=/* @__PURE__ */r("itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly");function et(e){return!!e||""===e}function en(e,t){if(e===t)return!0;let n=b(e),r=b(t);if(n||r)return!!n&&!!r&&e.getTime()===t.getTime();if(n=E(e),r=E(t),n||r)return e===t;if(n=_(e),r=_(t),n||r)return!!n&&!!r&&function(e,t){if(e.length!==t.length)return!1;let n=!0;for(let r=0;n&&r<e.length;r++)n=en(e[r],t[r]);return n}(e,t);if(n=C(e),r=C(t),n||r){if(!n||!r)return!1;let l=Object.keys(e).length,o=Object.keys(t).length;if(l!==o)return!1;for(let n in e){let r=e.hasOwnProperty(n),l=t.hasOwnProperty(n);if(r&&!l||!r&&l||!en(e[n],t[n]))return!1}}return String(e)===String(t)}function er(e,t){return e.findIndex(e=>en(e,t))}let el=e=>T(e)?e:null==e?"":_(e)||C(e)&&(e.toString===k||!w(e.toString))?JSON.stringify(e,eo,2):String(e),eo=(e,t)=>t&&t.__v_isRef?eo(e,t.value):y(t)?{[`Map(${t.size})`]:[...t.entries()].reduce((e,[t,n])=>(e[`${t} =>`]=n,e),{})}:x(t)?{[`Set(${t.size})`]:[...t.values()]}:!C(t)||_(t)||A(t)?t:String(t)}),h.register("eeJ70",function(e,t){let n;l(e.exports,"BaseTransition",()=>h("TusQn").BaseTransition),l(e.exports,"BaseTransitionPropsValidators",()=>h("TusQn").BaseTransitionPropsValidators),l(e.exports,"callWithAsyncErrorHandling",()=>h("TusQn").callWithAsyncErrorHandling),l(e.exports,"camelize",()=>h("8POXm").camelize),l(e.exports,"computed",()=>h("TusQn").computed),l(e.exports,"createCommentVNode",()=>h("TusQn").createCommentVNode),l(e.exports,"createElementBlock",()=>h("TusQn").createElementBlock),l(e.exports,"createElementVNode",()=>h("TusQn").createElementVNode),l(e.exports,"createHydrationRenderer",()=>h("TusQn").createHydrationRenderer),l(e.exports,"createRenderer",()=>h("TusQn").createRenderer),l(e.exports,"createTextVNode",()=>h("TusQn").createTextVNode),l(e.exports,"createVNode",()=>h("TusQn").createVNode),l(e.exports,"defineComponent",()=>h("TusQn").defineComponent),l(e.exports,"Fragment",()=>h("TusQn").Fragment),l(e.exports,"getCurrentInstance",()=>h("TusQn").getCurrentInstance),l(e.exports,"getTransitionRawChildren",()=>h("TusQn").getTransitionRawChildren),l(e.exports,"h",()=>h("TusQn").h),l(e.exports,"initCustomFormatter",()=>h("TusQn").initCustomFormatter),l(e.exports,"inject",()=>h("TusQn").inject),l(e.exports,"isRuntimeOnly",()=>h("TusQn").isRuntimeOnly),l(e.exports,"nextTick",()=>h("TusQn").nextTick),l(e.exports,"normalizeClass",()=>h("8POXm").normalizeClass),l(e.exports,"onActivated",()=>h("TusQn").onActivated),l(e.exports,"onDeactivated",()=>h("TusQn").onDeactivated),l(e.exports,"onMounted",()=>h("TusQn").onMounted),l(e.exports,"onUnmounted",()=>h("TusQn").onUnmounted),l(e.exports,"onUpdated",()=>h("TusQn").onUpdated),l(e.exports,"openBlock",()=>h("TusQn").openBlock),l(e.exports,"provide",()=>h("TusQn").provide),l(e.exports,"reactive",()=>h("01W3b").reactive),l(e.exports,"ref",()=>h("01W3b").ref),l(e.exports,"renderList",()=>h("TusQn").renderList),l(e.exports,"resolveComponent",()=>h("TusQn").resolveComponent),l(e.exports,"resolveTransitionHooks",()=>h("TusQn").resolveTransitionHooks),l(e.exports,"setTransitionHooks",()=>h("TusQn").setTransitionHooks),l(e.exports,"shallowReactive",()=>h("01W3b").shallowReactive),l(e.exports,"Static",()=>h("TusQn").Static),l(e.exports,"toRaw",()=>h("01W3b").toRaw),l(e.exports,"useTransitionState",()=>h("TusQn").useTransitionState),l(e.exports,"warn",()=>h("TusQn").warn),l(e.exports,"watch",()=>h("TusQn").watch),l(e.exports,"watchEffect",()=>h("TusQn").watchEffect),l(e.exports,"watchPostEffect",()=>h("TusQn").watchPostEffect),l(e.exports,"withCtx",()=>h("TusQn").withCtx),l(e.exports,"shallowRef",()=>h("01W3b").shallowRef),l(e.exports,"unref",()=>h("01W3b").unref),l(e.exports,"toDisplayString",()=>h("8POXm").toDisplayString),l(e.exports,"createApp",()=>z),h("TusQn");var r=h("8POXm"),o=h("TusQn"),i=h("01W3b");h("01W3b"),h("8POXm");var r=h("8POXm");let s="undefined"!=typeof document?document:null,a=s&&/* @__PURE__ */s.createElement("template"),u=/\s*!important$/;function c(e,t,n){if((0,r.isArray)(n))n.forEach(n=>c(e,t,n));else if(null==n&&(n=""),t.startsWith("--"))e.setProperty(t,n);else{let l=function(e,t){let n=f[t];if(n)return n;let l=(0,r.camelize)(t);if("filter"!==l&&l in e)return f[t]=l;l=(0,r.capitalize)(l);for(let n=0;n<p.length;n++){let r=p[n]+l;if(r in e)return f[t]=r}return t}(e,t);u.test(n)?e.setProperty((0,r.hyphenate)(l),n.replace(u,""),"important"):e[l]=n}}let p=["Webkit","Moz","ms"],f={},d="http://www.w3.org/1999/xlink",m=/(?:Once|Passive|Capture)$/,g=0,_=/* @__PURE__ */Promise.resolve(),y=()=>g||(_.then(()=>g=0),g=Date.now()),x=/^on[a-z]/;"undefined"!=typeof HTMLElement&&HTMLElement;let b="transition",O="animation",w=(e,{slots:t})=>(0,o.h)(o.BaseTransition,k(e),t);w.displayName="Transition";let T={name:String,type:String,css:{type:Boolean,default:!0},duration:[String,Number,Object],enterFromClass:String,enterActiveClass:String,enterToClass:String,appearFromClass:String,appearActiveClass:String,appearToClass:String,leaveFromClass:String,leaveActiveClass:String,leaveToClass:String},E=w.props=/* @__PURE__ */(0,r.extend)({},o.BaseTransitionPropsValidators,T),C=(e,t=[])=>{(0,r.isArray)(e)?e.forEach(e=>e(...t)):e&&e(...t)},S=e=>!!e&&((0,r.isArray)(e)?e.some(e=>e.length>1):e.length>1);function k(e){let t={};for(let n in e)n in T||(t[n]=e[n]);if(!1===e.css)return t;let{name:n="v",type:l,duration:o,enterFromClass:i=`${n}-enter-from`,enterActiveClass:s=`${n}-enter-active`,enterToClass:a=`${n}-enter-to`,appearFromClass:u=i,appearActiveClass:c=s,appearToClass:p=a,leaveFromClass:f=`${n}-leave-from`,leaveActiveClass:d=`${n}-leave-active`,leaveToClass:h=`${n}-leave-to`}=e,m=function(e){if(null==e)return null;{if((0,r.isObject)(e))return[P(e.enter),P(e.leave)];let t=P(e);return[t,t]}}(o),g=m&&m[0],_=m&&m[1],{onBeforeEnter:y,onEnter:x,onEnterCancelled:b,onLeave:O,onLeaveCancelled:w,onBeforeAppear:E=y,onAppear:k=x,onAppearCancelled:F=b}=t,L=(e,t,n)=>{A(e,t?p:a),A(e,t?c:s),n&&n()},M=(e,t)=>{e._isLeaving=!1,A(e,f),A(e,h),A(e,d),t&&t()},j=e=>(t,n)=>{let r=e?k:x,o=()=>L(t,e,n);C(r,[t,o]),V(()=>{A(t,e?u:i),R(t,e?p:a),S(r)||N(t,l,g,o)})};return(0,r.extend)(t,{onBeforeEnter(e){C(y,[e]),R(e,i),R(e,s)},onBeforeAppear(e){C(E,[e]),R(e,u),R(e,c)},onEnter:j(!1),onAppear:j(!0),onLeave(e,t){e._isLeaving=!0;let n=()=>M(e,t);R(e,f),I(),R(e,d),V(()=>{e._isLeaving&&(A(e,f),R(e,h),S(O)||N(e,l,_,n))}),C(O,[e,n])},onEnterCancelled(e){L(e,!1),C(b,[e])},onAppearCancelled(e){L(e,!0),C(F,[e])},onLeaveCancelled(e){M(e),C(w,[e])}})}function P(e){let t=(0,r.toNumber)(e);return t}function R(e,t){t.split(/\s+/).forEach(t=>t&&e.classList.add(t)),(e._vtc||(e._vtc=/* @__PURE__ */new Set)).add(t)}function A(e,t){t.split(/\s+/).forEach(t=>t&&e.classList.remove(t));let{_vtc:n}=e;n&&(n.delete(t),n.size||(e._vtc=void 0))}function V(e){requestAnimationFrame(()=>{requestAnimationFrame(e)})}let F=0;function N(e,t,n,r){let l=e._endId=++F,o=()=>{l===e._endId&&r()};if(n)return setTimeout(o,n);let{type:i,timeout:s,propCount:a}=L(e,t);if(!i)return r();let u=i+"end",c=0,p=()=>{e.removeEventListener(u,f),o()},f=t=>{t.target===e&&++c>=a&&p()};setTimeout(()=>{c<a&&p()},s+1),e.addEventListener(u,f)}function L(e,t){let n=window.getComputedStyle(e),r=e=>(n[e]||"").split(", "),l=r(`${b}Delay`),o=r(`${b}Duration`),i=M(l,o),s=r(`${O}Delay`),a=r(`${O}Duration`),u=M(s,a),c=null,p=0,f=0;t===b?i>0&&(c=b,p=i,f=o.length):t===O?u>0&&(c=O,p=u,f=a.length):f=(c=(p=Math.max(i,u))>0?i>u?b:O:null)?c===b?o.length:a.length:0;let d=c===b&&/\b(transform|all)(,|$)/.test(r(`${b}Property`).toString());return{type:c,timeout:p,propCount:f,hasTransform:d}}function M(e,t){for(;e.length<t.length;)e=e.concat(e);return Math.max(...t.map((t,n)=>j(t)+j(e[n])))}function j(e){return 1e3*Number(e.slice(0,-1).replace(",","."))}function I(){return document.body.offsetHeight}let B=/* @__PURE__ */new WeakMap,D=/* @__PURE__ */new WeakMap,U={name:"TransitionGroup",props:/* @__PURE__ */(0,r.extend)({},E,{tag:String,moveClass:String}),setup(e,{slots:t}){let n,r;let l=(0,o.getCurrentInstance)(),s=(0,o.useTransitionState)();return(0,o.onUpdated)(()=>{if(!n.length)return;let t=e.moveClass||`${e.name||"v"}-move`;if(!function(e,t,n){let r=e.cloneNode();e._vtc&&e._vtc.forEach(e=>{e.split(/\s+/).forEach(e=>e&&r.classList.remove(e))}),n.split(/\s+/).forEach(e=>e&&r.classList.add(e)),r.style.display="none";let l=1===t.nodeType?t:t.parentNode;l.appendChild(r);let{hasTransform:o}=L(r);return l.removeChild(r),o}(n[0].el,l.vnode.el,t))return;n.forEach($),n.forEach(Q);let r=n.filter(W);I(),r.forEach(e=>{let n=e.el,r=n.style;R(n,t),r.transform=r.webkitTransform=r.transitionDuration="";let l=n._moveCb=e=>{(!e||e.target===n)&&(!e||/transform$/.test(e.propertyName))&&(n.removeEventListener("transitionend",l),n._moveCb=null,A(n,t))};n.addEventListener("transitionend",l)})}),()=>{let a=(0,i.toRaw)(e),u=k(a),c=a.tag||o.Fragment;n=r,r=t.default?(0,o.getTransitionRawChildren)(t.default()):[];for(let e=0;e<r.length;e++){let t=r[e];null!=t.key&&(0,o.setTransitionHooks)(t,(0,o.resolveTransitionHooks)(t,u,s,l))}if(n)for(let e=0;e<n.length;e++){let t=n[e];(0,o.setTransitionHooks)(t,(0,o.resolveTransitionHooks)(t,u,s,l)),B.set(t,t.el.getBoundingClientRect())}return(0,o.createVNode)(c,null,r)}}};function $(e){let t=e.el;t._moveCb&&t._moveCb(),t._enterCb&&t._enterCb()}function Q(e){D.set(e,e.el.getBoundingClientRect())}function W(e){let t=B.get(e),n=D.get(e),r=t.left-n.left,l=t.top-n.top;if(r||l){let t=e.el.style;return t.transform=t.webkitTransform=`translate(${r}px,${l}px)`,t.transitionDuration="0s",e}}U.props;let H=/* @__PURE__ */(0,r.extend)({patchProp:(e,t,n,l,i=!1,s,a,u,p)=>{var f;"class"===t?function(e,t,n){let r=e._vtc;r&&(t=(t?[t,...r]:[...r]).join(" ")),null==t?e.removeAttribute("class"):n?e.setAttribute("class",t):e.className=t}(e,l,i):"style"===t?function(e,t,n){let l=e.style,o=(0,r.isString)(n);if(n&&!o){if(t&&!(0,r.isString)(t))for(let e in t)null==n[e]&&c(l,e,"");for(let e in n)c(l,e,n[e])}else{let r=l.display;o?t!==n&&(l.cssText=n):t&&e.removeAttribute("style"),"_vod"in e&&(l.display=r)}}(e,n,l):(0,r.isOn)(t)?(0,r.isModelListener)(t)||function(e,t,n,l,i=null){let s=e._vei||(e._vei={}),a=s[t];if(l&&a)a.value=l;else{let[n,u]=function(e){let t;if(m.test(e)){let n;for(t={};n=e.match(m);)e=e.slice(0,e.length-n[0].length),t[n[0].toLowerCase()]=!0}let n=":"===e[2]?e.slice(3):(0,r.hyphenate)(e.slice(2));return[n,t]}(t);if(l){let a=s[t]=function(e,t){let n=e=>{if(e._vts){if(e._vts<=n.attached)return}else e._vts=Date.now();(0,o.callWithAsyncErrorHandling)(function(e,t){if(!(0,r.isArray)(t))return t;{let n=e.stopImmediatePropagation;return e.stopImmediatePropagation=()=>{n.call(e),e._stopped=!0},t.map(e=>t=>!t._stopped&&e&&e(t))}}(e,n.value),t,5,[e])};return n.value=e,n.attached=y(),n}(l,i);!function(e,t,n,r){e.addEventListener(t,n,r)}(e,n,a,u)}else a&&(function(e,t,n,r){e.removeEventListener(t,n,r)}(e,n,a,u),s[t]=void 0)}}(e,t,0,l,a):("."===t[0]?(t=t.slice(1),!0):"^"===t[0]?(t=t.slice(1),!1):(f=t,i?"innerHTML"===f||"textContent"===f||f in e&&x.test(f)&&(0,r.isFunction)(l):!("spellcheck"===f||"draggable"===f||"translate"===f||"form"===f||"list"===f&&"INPUT"===e.tagName||"type"===f&&"TEXTAREA"===e.tagName||x.test(f)&&(0,r.isString)(l))&&f in e))?function(e,t,n,l,o,i,s){if("innerHTML"===t||"textContent"===t){l&&s(l,o,i),e[t]=null==n?"":n;return}let a=e.tagName;if("value"===t&&"PROGRESS"!==a&&// custom elements may use _value internally
!a.includes("-")){e._value=n;let r="OPTION"===a?e.getAttribute("value"):e.value,l=null==n?"":n;r!==l&&(e.value=l),null==n&&e.removeAttribute(t);return}let u=!1;if(""===n||null==n){let l=typeof e[t];"boolean"===l?n=(0,r.includeBooleanAttr)(n):null==n&&"string"===l?(n="",u=!0):"number"===l&&(n=0,u=!0)}try{e[t]=n}catch(e){}u&&e.removeAttribute(t)}(e,t,l,s,a,u,p):("true-value"===t?e._trueValue=l:"false-value"===t&&(e._falseValue=l),function(e,t,n,l,o){if(l&&t.startsWith("xlink:"))null==n?e.removeAttributeNS(d,t.slice(6,t.length)):e.setAttributeNS(d,t,n);else{let l=(0,r.isSpecialBooleanAttr)(t);null==n||l&&!(0,r.includeBooleanAttr)(n)?e.removeAttribute(t):e.setAttribute(t,l?"":n)}}(e,t,l,i))}},{insert:(e,t,n)=>{t.insertBefore(e,n||null)},remove:e=>{let t=e.parentNode;t&&t.removeChild(e)},createElement:(e,t,n,r)=>{let l=t?s.createElementNS("http://www.w3.org/2000/svg",e):s.createElement(e,n?{is:n}:void 0);return"select"===e&&r&&null!=r.multiple&&l.setAttribute("multiple",r.multiple),l},createText:e=>s.createTextNode(e),createComment:e=>s.createComment(e),setText:(e,t)=>{e.nodeValue=t},setElementText:(e,t)=>{e.textContent=t},parentNode:e=>e.parentNode,nextSibling:e=>e.nextSibling,querySelector:e=>s.querySelector(e),setScopeId(e,t){e.setAttribute(t,"")},// __UNSAFE__
// Reason: innerHTML.
// Static content here can only come from compiled templates.
// As long as the user only uses trusted templates, this is safe.
insertStaticContent(e,t,n,r,l,o){let i=n?n.previousSibling:t.lastChild;if(l&&(l===o||l.nextSibling))for(;t.insertBefore(l.cloneNode(!0),n),l!==o&&(l=l.nextSibling););else{a.innerHTML=r?`<svg>${e}</svg>`:e;let l=a.content;if(r){let e=l.firstChild;for(;e.firstChild;)l.appendChild(e.firstChild);l.removeChild(e)}t.insertBefore(l,n)}return[// first
i?i.nextSibling:t.firstChild,// last
n?n.previousSibling:t.lastChild]}}),z=(...e)=>{let t=(n||(n=(0,o.createRenderer)(H))).createApp(...e),{mount:l}=t;return t.mount=e=>{let n=function(e){if((0,r.isString)(e)){let t=document.querySelector(e);return t}return e}(e);if(!n)return;let o=t._component;(0,r.isFunction)(o)||o.render||o.template||(o.template=n.innerHTML),n.innerHTML="";let i=l(n,!1,n instanceof SVGElement);return n instanceof Element&&(n.removeAttribute("v-cloak"),n.setAttribute("data-v-app","")),i},t}}),h.register("a5J4w",function(e,t){l(e.exports,"render",()=>a),h("ecd4d");var n=h("TusQn");let r={class:"bg-gray-800 text-white sticky top-0 w-full z-10"},o={class:"flex items-center max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 h-14"},i=/*#__PURE__*/(0,n.createElementVNode)("span",{class:"text-2xl font-bold text-white"},"Online Store",-1),s={class:"ms-auto"};function a(e,t){let l=(0,n.resolveComponent)("router-link"),a=(0,n.resolveComponent)("router-view");return(0,n.openBlock)(),(0,n.createElementBlock)(n.Fragment,null,[(0,n.createElementVNode)("nav",r,[(0,n.createElementVNode)("div",o,[(0,n.createVNode)(l,{to:"/"},{default:(0,n.withCtx)(()=>[i]),_:1}),(0,n.createElementVNode)("div",s,[(0,n.createVNode)(l,{to:"/",class:"mx-3"},{default:(0,n.withCtx)(()=>[(0,n.createTextVNode)("Home")]),_:1}),(0,n.createVNode)(l,{to:"/about",class:"mx-3"},{default:(0,n.withCtx)(()=>[(0,n.createTextVNode)("About")]),_:1})])])]),(0,n.createElementVNode)("main",null,[(0,n.createVNode)(a)])],64)}}),h.register("fWmT1",function(e,t){l(e.exports,"default",()=>n);var n=e=>{}}),h.register("hmXi5",function(e,t){Object.defineProperty(e.exports,"__esModule",{value:!0,configurable:!0}),l(e.exports,"default",()=>n),h("ecd4d");var n=(0,h("TusQn").defineComponent)({data:()=>({products:[],selected:{}}),created(){fetch("https://mock.shop/api?query={products(first:%2020){edges%20{node%20{id%20title%20description%20featuredImage%20{id%20url}%20variants(first:%203){edges%20{node%20{price%20{amount%20currencyCode}}}}}}}}").then(e=>e.json()).then(e=>{this.products=[];for(let t=0;t<e.data.products.edges.length;t++){let n=e.data.products.edges[t];this.products.push({id:n.node.id,title:n.node.title,description:n.node.description,featuredImage:n.node.featuredImage,variants:n.node.variants})}})}})}),h.register("343ow",function(e,t){l(e.exports,"render",()=>O),h("ecd4d");var n=h("TusQn"),r=h("8POXm");let o={class:"mx-auto max-w-2xl px-4 py-16 sm:px-6 sm:py-24 lg:max-w-7xl lg:px-8"},i=/*#__PURE__*/(0,n.createElementVNode)("h2",{class:"text-2xl font-bold tracking-tight text-gray-900"},"Customers also purchased",-1),s={class:"mt-6 grid grid-cols-1 gap-x-6 gap-y-10 sm:grid-cols-2 lg:grid-cols-4 xl:gap-x-8"},a=["onClick"],u={class:"aspect-h-1 aspect-w-1 w-full overflow-hidden rounded-md bg-gray-200 lg:aspect-none group-hover:opacity-75 lg:h-80"},c=["src","alt"],p={class:"mt-4 flex justify-between"},f={class:"text-md text-gray-700"},d={class:"text-sm text-gray-500"},m=["innerHTML"],g=["innerHTML"],_={key:0,class:"fixed bottom-0 right-0 w-full h-full max-w-2xl bg-white z-20"},y={class:"bg-gray-200"},x=["src"],b=/*#__PURE__*/(0,n.createElementVNode)("section",{class:"p-4"},null,-1);function O(e,t,l,h,O,w){return(0,n.openBlock)(),(0,n.createElementBlock)(n.Fragment,null,[(0,n.createElementVNode)("div",{class:(0,r.normalizeClass)(["bg-white",{"blur-sm":e.selected.id,"max-h-screen":e.selected.id,"overflow-hidden":e.selected.id}])},[(0,n.createElementVNode)("div",o,[i,(0,n.createElementVNode)("div",s,[((0,n.openBlock)(!0),(0,n.createElementBlock)(n.Fragment,null,(0,n.renderList)(e.products,t=>((0,n.openBlock)(),(0,n.createElementBlock)("div",{key:t.id,class:"group relative",onClick:n=>e.selected=t},[(0,n.createElementVNode)("div",u,[(0,n.createElementVNode)("img",{src:t.featuredImage.url,alt:t.title,class:"h-full w-full object-cover object-center lg:h-full lg:w-full"},null,8,c)]),(0,n.createElementVNode)("div",p,[(0,n.createElementVNode)("div",null,[(0,n.createElementVNode)("h3",f,(0,r.toDisplayString)(t.title),1),(0,n.createElementVNode)("span",d,[(0,n.createElementVNode)("span",{innerHTML:t.variants.edges[0].node.price.currencyCode},null,8,m),(0,n.createElementVNode)("span",{class:"px-2",innerHTML:"$"+t.variants.edges[0].node.price.amount},null,8,g)])])])],8,a))),128))])])],2),e.selected.id?((0,n.openBlock)(),(0,n.createElementBlock)("div",_,[(0,n.createElementVNode)("article",null,[(0,n.createElementVNode)("header",y,[(0,n.createElementVNode)("img",{src:e.selected.featuredImage.url,alt:"img"},null,8,x),(0,n.createElementVNode)("button",{class:"absolute top-0 right-0 text-gray-800 opacity-50 hover:opacity-100",onClick:t[0]||(t[0]=t=>e.selected.id="")},"Close")]),b])])):(0,n.createCommentVNode)("",!0)],64)}}),h.register("MIFpg",function(e,t){l(e.exports,"default",()=>n);var n=e=>{}}),h.register("kgbrZ",function(e,t){e.exports=import("./"+h("27Lyk").resolve("1A2Cq")).then(()=>h("7OYHT"))}),h("ecd4d");var m=h("eeJ70");(e={}).render=h("a5J4w").render,h("fWmT1").default(e),e.__scopeId="data-v-3e8271",e.__file="app.vue",/*!
  * vue-router v4.2.4
  * (c) 2023 Eduardo San Martin Morote
  * @license MIT
  */h("ecd4d");var g=h("TusQn"),_=h("01W3b");function y(){// @ts-ignore
return"undefined"!=typeof navigator&&"undefined"!=typeof window?window:void 0!==p?p:{}}const x="function"==typeof Proxy;class b{constructor(e,r){this.target=null,this.targetQueue=[],this.onQueue=[],this.plugin=e,this.hook=r;let l={};if(e.settings)for(let t in e.settings){let n=e.settings[t];l[t]=n.defaultValue}let o=`__vue-devtools-plugin-settings__${e.id}`,i=Object.assign({},l);try{let e=localStorage.getItem(o),t=JSON.parse(e);Object.assign(i,t)}catch(e){// noop
}this.fallbacks={getSettings:()=>i,setSettings(e){try{localStorage.setItem(o,JSON.stringify(e))}catch(e){// noop
}i=e},now:()=>{var e;return(void 0!==t||("undefined"!=typeof window&&window.performance?(t=!0,n=window.performance):void 0!==p&&(null===(e=p.perf_hooks)||void 0===e?void 0:e.performance)?(t=!0,n=p.perf_hooks.performance):t=!1),t)?n.now():Date.now()}},r&&r.on("plugin:settings:set",(e,t)=>{e===this.plugin.id&&this.fallbacks.setSettings(t)}),this.proxiedOn=new Proxy({},{get:(e,t)=>this.target?this.target.on[t]:(...e)=>{this.onQueue.push({method:t,args:e})}}),this.proxiedTarget=new Proxy({},{get:(e,t)=>this.target?this.target[t]:"on"===t?this.proxiedOn:Object.keys(this.fallbacks).includes(t)?(...e)=>(this.targetQueue.push({method:t,args:e,resolve:()=>{}}),this.fallbacks[t](...e)):(...e)=>new Promise(n=>{this.targetQueue.push({method:t,args:e,resolve:n})})})}async setRealTarget(e){for(let t of(this.target=e,this.onQueue))this.target.on[t.method](...t.args);for(let e of this.targetQueue)e.resolve(await this.target[e.method](...e.args))}}const O="undefined"!=typeof window,w=Object.assign;function T(e,t){let n={};for(let r in t){let l=t[r];n[r]=C(l)?l.map(e):e(l)}return n}const E=()=>{},C=Array.isArray,S=/\/$/,k=e=>e.replace(S,"");/**
 * Transforms a URI into a normalized history location
 *
 * @param parseQuery
 * @param location - URI to normalize
 * @param currentLocation - current absolute location. Allows resolving relative
 * paths. Must start with `/`. Defaults to `/`
 * @returns a normalized history location
 */function P(e,t,n="/"){let r,l={},o="",i="",s=t.indexOf("#"),a=t.indexOf("?");// empty path means a relative query or hash `?foo=f`, `#thing`
return s<a&&s>=0&&(a=-1),a>-1&&(r=t.slice(0,a),l=e(o=t.slice(a+1,s>-1?s:t.length))),s>-1&&(r=r||t.slice(0,s),// keep the # character
i=t.slice(s,t.length)),{fullPath:// no search and no query
(r=/**
 * Resolves a relative path that starts with `.`.
 *
 * @param to - path location we are resolving
 * @param from - currentLocation.path, should start with `/`
 */function(e,t){let n,r;if(e.startsWith("/"))return e;if(!e)return t;let l=t.split("/"),o=e.split("/"),i=o[o.length-1];(".."===i||"."===i)&&o.push("");let s=l.length-1;for(n=0;n<o.length;n++)// we stay on the same position
if("."!==(r=o[n])){// go up in the from array
if(".."===r)s>1&&s--;else break}return l.slice(0,s).join("/")+"/"+o// ensure we use at least the last element in the toSegments
.slice(n-(n===o.length?1:0)).join("/")}(null!=r?r:t,n))+(o&&"?")+o+i,path:r,query:l,hash:i}}/**
 * Strips off the base from the beginning of a location.pathname in a non-case-sensitive way.
 *
 * @param pathname - location.pathname
 * @param base - base to strip off
 */function R(e,t){return(// no base or base is not found at the beginning
t&&e.toLowerCase().startsWith(t.toLowerCase())?e.slice(t.length)||"/":e)}/**
 * Check if two `RouteRecords` are equal. Takes into account aliases: they are
 * considered equal to the `RouteRecord` they are aliasing.
 *
 * @param a - first {@link RouteRecord}
 * @param b - second {@link RouteRecord}
 */function A(e,t){// since the original record has an undefined value for aliasOf
// but all aliases point to the original record, this will always compare
// the original record
return(e.aliasOf||e)===(t.aliasOf||t)}function V(e,t){if(Object.keys(e).length!==Object.keys(t).length)return!1;for(let l in e){var n,r;if(n=e[l],r=t[l],C(n)?!F(n,r):C(r)?!F(r,n):n!==r)return!1}return!0}/**
 * Check if two arrays are the same or if an array with one single entry is the
 * same as another primitive value. Used to check query and parameters
 *
 * @param a - array of values
 * @param b - array of values or a single value
 */function F(e,t){return C(t)?e.length===t.length&&e.every((e,n)=>e===t[n]):1===e.length&&e[0]===t}(o=a||(a={})).pop="pop",o.push="push",(i=u||(u={})).back="back",i.forward="forward",i.unknown="";// remove any character before the hash
const N=/^[^#]+#/;function L(e,t){return e.replace(N,"#")+t}const M=()=>({left:window.pageXOffset,top:window.pageYOffset});function j(e,t){let n=history.state?history.state.position-t:-1;return n+e}const I=new Map;// TODO: RFC about how to save scroll position
/**
 * ScrollBehavior instance used by the router to compute and restore the scroll
 * position when navigating.
 */// export interface ScrollHandler<ScrollPositionEntry extends HistoryStateValue, ScrollPosition extends ScrollPositionEntry> {
//   // returns a scroll position that can be saved in history
//   compute(): ScrollPositionEntry
//   // can take an extended ScrollPositionEntry
//   scroll(position: ScrollPosition): void
// }
// export const scrollHandler: ScrollHandler<ScrollPosition> = {
//   compute: computeScroll,
//   scroll: scrollToPosition,
// }
let B=()=>location.protocol+"//"+location.host;/**
 * Creates a normalized history location from a window.location object
 * @param base - The base path
 * @param location - The window.location object
 */function D(e,t){let{pathname:n,search:r,hash:l}=t,o=e.indexOf("#");if(o>-1){let t=l.includes(e.slice(o))?e.slice(o).length:1,n=l.slice(t);return"/"!==n[0]&&(n="/"+n),R(n,"")}let i=R(n,e);return i+r+l}/**
 * Creates a state object
 */function U(e,t,n,r=!1,l=!1){return{back:e,current:t,forward:n,replaced:r,position:window.history.length,scroll:l?M():null}}function $(e){return"string"==typeof e||"symbol"==typeof e}/**
 * Initial route location where the router is. Can be used in navigation guards
 * to differentiate the initial navigation.
 *
 * @example
 * ```js
 * import { START_LOCATION } from 'vue-router'
 *
 * router.beforeEach((to, from) => {
 *   if (from === START_LOCATION) {
 *     // initial navigation
 *   }
 * })
 * ```
 */const Q={path:"/",name:void 0,params:{},query:{},hash:"",fullPath:"/",matched:[],meta:{},redirectedFrom:void 0},W=Symbol("");function H(e,t){return w(Error(),{type:e,[W]:!0},t)}function z(e,t){return e instanceof Error&&W in e&&(null==t||!!(e.type&t))}/**
     * An aborted navigation is a navigation that failed because a navigation
     * guard returned `false` or called `next(false)`
     */(s=c||(c={}))[s.aborted=4]="aborted",/**
     * A cancelled navigation is a navigation that failed because a more recent
     * navigation finished started (not necessarily finished).
     */s[s.cancelled=8]="cancelled",/**
     * A duplicated navigation is a navigation that failed because it was
     * initiated while already being at the exact same location.
     */s[s.duplicated=16]="duplicated";// default pattern for a param: non-greedy everything but /
const Y="[^/]+?",J={sensitive:!1,strict:!1,start:!0,end:!0},G=/[.+*?^${}()[\]/\\]/g;/**
 * This allows detecting splats at the end of a path: /home/:id(.*)*
 *
 * @param score - score to check
 * @returns true if the last entry is negative
 */function q(e){let t=e[e.length-1];return e.length>0&&t[t.length-1]<0}const K={type:0/* TokenType.Static */,value:""},X=/[a-zA-Z0-9_]/;function Z(e,t){let n={};for(let r of t)r in e&&(n[r]=e[r]);return n}/**
 * Checks if a record or any of its parent is an alias
 * @param record
 */function ee(e){for(;e;){if(e.record.aliasOf)return!0;e=e.parent}return!1}function et(e,t){let n={};for(let r in e)n[r]=r in t?t[r]:e[r];return n}/**
 * Encoding Rules ␣ = Space Path: ␣ " < > # ? { } Query: ␣ " < > # & = Hash: ␣ "
 * < > `
 *
 * On top of that, the RFC3986 (https://tools.ietf.org/html/rfc3986#section-2.2)
 * defines some extra characters to be encoded. Most browsers do not encode them
 * in encodeURI https://github.com/whatwg/url/issues/369, so it may be safer to
 * also encode `!'()*`. Leaving un-encoded only ASCII alphanumeric(`a-zA-Z0-9`)
 * plus `-._~`. This extra safety should be applied to query by patching the
 * string returned by encodeURIComponent encodeURI also encodes `[\]^`. `\`
 * should be encoded to avoid ambiguity. Browsers (IE, FF, C) transform a `\`
 * into a `/` if directly typed in. The _backtick_ (`````) should also be
 * encoded everywhere because some browsers like FF encode it when directly
 * written while others don't. Safari and IE don't encode ``"<>{}``` in hash.
 */// const EXTRA_RESERVED_RE = /[!'()*]/g
// const encodeReservedReplacer = (c: string) => '%' + c.charCodeAt(0).toString(16)
const en=/#/g,er=/&/g,el=/\//g,eo=/=/g,ei=/\?/g,es=/\+/g,ea=/%5B/g,eu=/%5D/g,ec=/%5E/g,ep=/%60/g,ef=/%7B/g,ed=/%7C/g,eh=/%7D/g,em=/%20/g;// %23
/**
 * Encode characters that need to be encoded on the path, search and hash
 * sections of the URL.
 *
 * @internal
 * @param text - string to encode
 * @returns encoded string
 */function eg(e){return encodeURI(""+e).replace(ed,"|").replace(ea,"[").replace(eu,"]")}/**
 * Encode characters that need to be encoded query values on the query
 * section of the URL.
 *
 * @param text - string to encode
 * @returns encoded string
 */function ev(e){return eg(e)// Encode the space as +, encode the + to differentiate it from the space
.replace(es,"%2B").replace(em,"+").replace(en,"%23").replace(er,"%26").replace(ep,"`").replace(ef,"{").replace(eh,"}").replace(ec,"^")}/**
 * Encode characters that need to be encoded on the path section of the URL as a
 * param. This function encodes everything {@link encodePath} does plus the
 * slash (`/`) character. If `text` is `null` or `undefined`, returns an empty
 * string instead.
 *
 * @param text - string to encode
 * @returns encoded string
 */function e_(e){return null==e?"":eg(e).replace(en,"%23").replace(ei,"%3F").replace(el,"%2F")}/**
 * Decode text using `decodeURIComponent`. Returns the original text if it
 * fails.
 *
 * @param text - string to decode
 * @returns decoded string
 */function ey(e){try{return decodeURIComponent(""+e)}catch(e){}return""+e}/**
 * Transforms a queryString into a {@link LocationQuery} object. Accept both, a
 * version with the leading `?` and without Should work as URLSearchParams

 * @internal
 *
 * @param search - search string to parse
 * @returns a query object
 */function ex(e){let t={};// avoid creating an object with an empty key and empty value
// because of split('&')
if(""===e||"?"===e)return t;let n="?"===e[0],r=(n?e.slice(1):e).split("&");for(let e=0;e<r.length;++e){// pre decode the + into space
let n=r[e].replace(es," "),l=n.indexOf("="),o=ey(l<0?n:n.slice(0,l)),i=l<0?null:ey(n.slice(l+1));if(o in t){// an extra variable for ts types
let e=t[o];C(e)||(e=t[o]=[e]),e.push(i)}else t[o]=i}return t}/**
 * Stringifies a {@link LocationQueryRaw} object. Like `URLSearchParams`, it
 * doesn't prepend a `?`
 *
 * @internal
 *
 * @param query - query object to stringify
 * @returns string version of the query without the leading `?`
 */function eb(e){let t="";for(let n in e){let r=e[n];if(n=ev(n).replace(eo,"%3D"),null==r){void 0!==r&&(t+=(t.length?"&":"")+n);continue}// keep null values
let l=C(r)?r.map(e=>e&&ev(e)):[r&&ev(r)];l.forEach(e=>{void 0!==e&&(// only append & with non-empty search
t+=(t.length?"&":"")+n,null!=e&&(t+="="+e))})}return t}/**
 * RouteRecord being rendered by the closest ancestor Router View. Used for
 * `onBeforeRouteUpdate` and `onBeforeRouteLeave`. rvlm stands for Router View
 * Location Matched
 *
 * @internal
 */const eO=Symbol(""),ew=Symbol(""),eT=Symbol(""),eE=Symbol(""),eC=Symbol("");/**
 * Create a list of callbacks that can be reset. Used to create before and after navigation guards list
 */function eS(){let e=[];return{add:function(t){return e.push(t),()=>{let n=e.indexOf(t);n>-1&&e.splice(n,1)}},list:()=>e.slice(),reset:function(){e=[]}}}function ek(e,t,n,r,l){// keep a reference to the enterCallbackArray to prevent pushing callbacks if a new navigation took place
let o=r&&// name is defined if record is because of the function overload
(r.enterCallbacks[l]=r.enterCallbacks[l]||[]);return()=>new Promise((i,s)=>{let a=e=>{!1===e?s(H(4/* ErrorTypes.NAVIGATION_ABORTED */,{from:n,to:t})):e instanceof Error?s(e):"string"==typeof e||e&&"object"==typeof e?s(H(2/* ErrorTypes.NAVIGATION_GUARD_REDIRECT */,{from:t,to:e})):(o&&// since enterCallbackArray is truthy, both record and name also are
    r.enterCallbacks[l]===o&&"function"==typeof e&&o.push(e),i())},u=e.call(r&&r.instances[l],t,n,a),c=Promise.resolve(u);e.length<3&&(c=c.then(a)),c.catch(e=>s(e))})}function eP(e,t,n,r){let l=[];for(let o of e)for(let e in o.components){let i=o.components[e];// skip update and leave guards if the route component is not mounted
if("beforeRouteEnter"===t||o.instances[e]){if("object"==typeof i||"displayName"in i||"props"in i||"__vccOpts"in i){// __vccOpts is added by vue-class-component and contain the regular options
let s=i.__vccOpts||i,a=s[t];a&&l.push(ek(a,n,r,o,e))}else{// start requesting the chunk already
let s=i();l.push(()=>s.then(l=>{if(!l)return Promise.reject(Error(`Couldn't resolve component "${e}" at "${o.path}"`));let i=l.__esModule||"Module"===l[Symbol.toStringTag]?l.default:l;// replace the function with the resolved component
    // cannot be null or undefined because we went into the for loop
    o.components[e]=i;// __vccOpts is added by vue-class-component and contain the regular options
    let s=i.__vccOpts||i,a=s[t];return a&&ek(a,n,r,o,e)()}))}}}return l}// TODO: we could allow currentRoute as a prop to expose `isActive` and
// `isExactActive` behavior should go through an RFC
function eR(e){let t=(0,g.inject)(eT),n=(0,g.inject)(eE),r=(0,_.computed)(()=>t.resolve((0,_.unref)(e.to))),l=(0,_.computed)(()=>{let{matched:e}=r.value,{length:t}=e,l=e[t-1],o=n.matched;if(!l||!o.length)return -1;let i=o.findIndex(A.bind(null,l));if(i>-1)return i;// possible parent record
let s=eV(e[t-2]);return t>1&&// if the parent and matched route have the same path, this link is
// referring to the empty child. Or we currently are on a different
// child of the same parent
eV(l)===s&&// avoid comparing the child with its parent
o[o.length-1].path!==s?o.findIndex(A.bind(null,e[t-2])):i}),o=(0,_.computed)(()=>l.value>-1&&function(e,t){for(let n in t){let r=t[n],l=e[n];if("string"==typeof r){if(r!==l)return!1}else if(!C(l)||l.length!==r.length||r.some((e,t)=>e!==l[t]))return!1}return!0}(n.params,r.value.params)),i=(0,_.computed)(()=>l.value>-1&&l.value===n.matched.length-1&&V(n.params,r.value.params));// devtools only
if(__VUE_PROD_DEVTOOLS__&&O){let e=(0,g.getCurrentInstance)();if(e){let t={route:r.value,isActive:o.value,isExactActive:i.value};// @ts-expect-error: this is internal
e.__vrl_devtools=e.__vrl_devtools||[],// @ts-expect-error: this is internal
e.__vrl_devtools.push(t),(0,g.watchEffect)(()=>{t.route=r.value,t.isActive=o.value,t.isExactActive=i.value},{flush:"post"})}}/**
     * NOTE: update {@link _RouterLinkI}'s `$slots` type when updating this
     */return{route:r,href:(0,_.computed)(()=>r.value.href),isActive:o,isExactActive:i,navigate:function(n={}){return!function(e){// don't redirect with control keys
if(!e.metaKey&&!e.altKey&&!e.ctrlKey&&!e.shiftKey&&!e.defaultPrevented&&(void 0===e.button||0===e.button)){// don't redirect if `target="_blank"`
// @ts-expect-error getAttribute does exist
if(e.currentTarget&&e.currentTarget.getAttribute){// @ts-expect-error getAttribute exists
let t=e.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(t))return}return e.preventDefault&&e.preventDefault(),!0}}(n)?Promise.resolve():t[(0,_.unref)(e.replace)?"replace":"push"]((0,_.unref)(e.to)).catch(E)}}}const eA=/*#__PURE__*/(0,g.defineComponent)({name:"RouterLink",compatConfig:{MODE:3},props:{to:{type:[String,Object],required:!0},replace:Boolean,activeClass:String,// inactiveClass: String,
exactActiveClass:String,custom:Boolean,ariaCurrentValue:{type:String,default:"page"}},useLink:eR,setup(e,{slots:t}){let n=(0,_.reactive)(eR(e)),{options:r}=(0,g.inject)(eT),l=(0,_.computed)(()=>({[eF(e.activeClass,r.linkActiveClass,"router-link-active")]:n.isActive,// [getLinkClass(
    //   props.inactiveClass,
    //   options.linkInactiveClass,
    //   'router-link-inactive'
    // )]: !link.isExactActive,
    [eF(e.exactActiveClass,r.linkExactActiveClass,"router-link-exact-active")]:n.isExactActive}));return()=>{let r=t.default&&t.default(n);return e.custom?r:(0,g.h)("a",{"aria-current":n.isExactActive?e.ariaCurrentValue:null,href:n.href,// this would override user added attrs but Vue will still add
// the listener, so we end up triggering both
onClick:n.navigate,class:l.value},r)}}});/**
 * Get the original path value of a record by following its aliasOf
 * @param record
 */function eV(e){return e?e.aliasOf?e.aliasOf.path:e.path:""}/**
 * Utility class to get the active class based on defaults.
 * @param propClass
 * @param globalClass
 * @param defaultClass
 */const eF=(e,t,n)=>null!=e?e:null!=t?t:n,eN=/*#__PURE__*/(0,g.defineComponent)({name:"RouterView",// #674 we manually inherit them
inheritAttrs:!1,props:{name:{type:String,default:"default"},route:Object},// Better compat for @vue/compat users
// https://github.com/vuejs/router/issues/1315
compatConfig:{MODE:3},setup(e,{attrs:t,slots:n}){let r=(0,g.inject)(eC),l=(0,_.computed)(()=>e.route||r.value),o=(0,g.inject)(ew,0),i=(0,_.computed)(()=>{let e,t=(0,_.unref)(o),{matched:n}=l.value;for(;(e=n[t])&&!e.components;)t++;return t}),s=(0,_.computed)(()=>l.value.matched[i.value]);(0,g.provide)(ew,(0,_.computed)(()=>i.value+1)),(0,g.provide)(eO,s),(0,g.provide)(eC,l);let a=(0,_.ref)();return(// watch at the same time the component instance, the route record we are
// rendering, and the name
(0,g.watch)(()=>[a.value,s.value,e.name],([e,t,n],[r,l,o])=>{t&&(// this will update the instance for new instances as well as reused
// instances when navigating to a new route
t.instances[n]=e,l&&l!==t&&e&&e===r&&(t.leaveGuards.size||(t.leaveGuards=l.leaveGuards),t.updateGuards.size||(t.updateGuards=l.updateGuards))),!e||!t||// if there is no instance but to and from are the same this might be
// the first visit
l&&A(t,l)&&r||(t.enterCallbacks[n]||[]).forEach(t=>t(e))},{flush:"post"}),()=>{let r=l.value,o=e.name,u=s.value,c=u&&u.components[o];if(!c)return eL(n.default,{Component:c,route:r});// props from route configuration
let p=u.props[o],f=p?!0===p?r.params:"function"==typeof p?p(r):p:null,d=(0,g.h)(c,w({},f,t,{onVnodeUnmounted:e=>{e.component.isUnmounted&&(u.instances[o]=null)},ref:a}));if(__VUE_PROD_DEVTOOLS__&&O&&d.ref){// TODO: can display if it's an alias, its props
let e={depth:i.value,name:u.name,path:u.path,meta:u.meta},t=C(d.ref)?d.ref.map(e=>e.i):[d.ref.i];t.forEach(t=>{// @ts-expect-error
t.__vrv_devtools=e})}return(// h and <component :is="..."> both accept vnodes
eL(n.default,{Component:d,route:r})||d)})}});function eL(e,t){if(!e)return null;let n=e(t);return 1===n.length?n[0]:n}/**
 * Copies a route location and removes any problematic properties that cannot be shown in devtools (e.g. Vue instances).
 *
 * @param routeLocation - routeLocation to format
 * @param tooltip - optional tooltip
 * @returns a copy of the routeLocation
 */function eM(e,t){let n=w({},e,{// remove variables that can contain vue instances
matched:e.matched.map(e=>(function(e,t){let n={};for(let r in e)t.includes(r)||(n[r]=e[r]);return n})(e,["instances","children","aliasOf"]))});return{_custom:{type:null,readOnly:!0,display:e.fullPath,tooltip:t,value:n}}}function ej(e){return{_custom:{display:e}}}// to support multiple router instances
let eI=0;function eB(e){let t=[],{record:n}=e;null!=n.name&&t.push({label:String(n.name),textColor:0,backgroundColor:2282478}),n.aliasOf&&t.push({label:"alias",textColor:0,backgroundColor:16486972}),e.__vd_match&&t.push({label:"matches",textColor:0,backgroundColor:15485081}),e.__vd_exactActive&&t.push({label:"exact",textColor:0,backgroundColor:8702998}),e.__vd_active&&t.push({label:"active",textColor:0,backgroundColor:2450411}),n.redirect&&t.push({label:"string"==typeof n.redirect?`redirect: ${n.redirect}`:"redirects",textColor:16777215,backgroundColor:6710886});// add an id to be able to select it. Using the `path` is not possible because
// empty path children would collide with their parents
let r=n.__vd_id;return null==r&&(r=String(eD++),n.__vd_id=r),{id:r,label:n.path,tags:t,children:e.children.map(eB)}}//  incremental id for route records and inspector state
let eD=0;const eU=/^\/(.*)\/([a-z]*)$/;function e$(e){e.__vd_match=!1,e.children.forEach(e$)}(r=h("hmXi5")).__esModule&&(r=r.default),r.render=h("343ow").render,h("MIFpg").default(r),r.__scopeId="data-v-4735a0",r.__file="home.vue";var eQ=r,eW=/**
 * Creates a Router instance that can be used by a Vue app.
 *
 * @param options - {@link RouterOptions}
 */function(e){let t,n,r;let l=/**
 * Creates a Router Matcher.
 *
 * @internal
 * @param routes - array of initial routes
 * @param globalOptions - global route options
 */function(e,t){// normalized ordered array of matchers
let n=[],r=new Map;function l(e,i,s){let a,u;// used later on to remove by name
let c=!s,p={path:e.path,redirect:e.redirect,name:e.name,meta:e.meta||{},aliasOf:void 0,beforeEnter:e.beforeEnter,props:/**
 * Normalize the optional `props` in a record to always be an object similar to
 * components. Also accept a boolean for components.
 * @param record
 */function(e){let t={},n=e.props||!1;if("component"in e)t.default=n;else // Would need user feedback for use cases
for(let r in e.components)t[r]="object"==typeof n?n[r]:n;return t}(e),children:e.children||[],instances:{},leaveGuards:new Set,updateGuards:new Set,enterCallbacks:{},components:"components"in e?e.components||null:e.component&&{default:e.component}};// we might be the child of an alias
p.aliasOf=s&&s.record;let f=et(t,e),d=[p];if("alias"in e){let t="string"==typeof e.alias?[e.alias]:e.alias;for(let e of t)d.push(w({},p,{// this allows us to hold a copy of the `components` option
// so that async components cache is hold on the original record
components:s?s.record.components:p.components,path:e,// we might be the child of an alias
aliasOf:s?s.record:p}))}for(let t of d){let{path:d}=t;// Build up the path for nested routes if the child isn't an absolute
// route. Only add the / delimiter if the child path isn't empty and if the
// parent path doesn't have a trailing slash
if(i&&"/"!==d[0]){let e=i.record.path,n="/"===e[e.length-1]?"":"/";t.path=i.record.path+(d&&n+d)}if(// create the object beforehand, so it can be passed to children
a=function(e,t,n){let r=/**
 * Creates a path parser from an array of Segments (a segment is an array of Tokens)
 *
 * @param segments - array of segments returned by tokenizePath
 * @param extraOptions - optional options for the regexp
 * @returns a PathParser
 */function(e,t){let n=w({},J,t),r=[],l=n.start?"^":"",o=[];for(let t of e){// the root segment needs special treatment
let e=t.length?[]:[90/* PathScore.Root */];n.strict&&!t.length&&(l+="/");for(let r=0;r<t.length;r++){let i=t[r],s=40/* PathScore.Segment */+(n.sensitive?.25/* PathScore.BonusCaseSensitive */:0);if(0/* TokenType.Static */===i.type)r||(l+="/"),l+=i.value.replace(G,"\\$&"),s+=40/* PathScore.Static */;else if(1/* TokenType.Param */===i.type){let{value:e,repeatable:n,optional:a,regexp:u}=i;o.push({name:e,repeatable:n,optional:a});let c=u||Y;// the user provided a custom regexp /:id(\\d+)
if(c!==Y){s+=10/* PathScore.BonusCustomRegExp */;// make sure the regexp is valid before using it
try{RegExp(`(${c})`)}catch(t){throw Error(`Invalid custom RegExp for param "${e}" (${c}): `+t.message)}}// when we repeat we must take care of the repeating leading slash
let p=n?`((?:${c})(?:/(?:${c}))*)`:`(${c})`;r||(p=// or /:p?-:p2
a&&t.length<2?`(?:/${p})`:"/"+p),a&&(p+="?"),l+=p,s+=20/* PathScore.Dynamic */,a&&(s+=-8/* PathScore.BonusOptional */),n&&(s+=-20/* PathScore.BonusRepeatable */),".*"===c&&(s+=-50/* PathScore.BonusWildcard */)}e.push(s)}// an empty array like /home/ -> [[{home}], []]
// if (!segment.length) pattern += '/'
r.push(e)}// only apply the strict bonus to the last score
if(n.strict&&n.end){let e=r.length-1;r[e][r[e].length-1]+=.7000000000000001/* PathScore.BonusStrict */}n.strict||(l+="/?"),n.end?l+="$":n.strict&&(l+="(?:/|$)");let i=new RegExp(l,n.sensitive?"":"i");return{re:i,score:r,keys:o,parse:function(e){let t=e.match(i),n={};if(!t)return null;for(let e=1;e<t.length;e++){let r=t[e]||"",l=o[e-1];n[l.name]=r&&l.repeatable?r.split("/"):r}return n},stringify:function(t){let n="",r=!1;for(let l of e)for(let e of(r&&n.endsWith("/")||(n+="/"),r=!1,l))if(0/* TokenType.Static */===e.type)n+=e.value;else if(1/* TokenType.Param */===e.type){let{value:o,repeatable:i,optional:s}=e,a=o in t?t[o]:"";if(C(a)&&!i)throw Error(`Provided param "${o}" is an array but it is not repeatable (* or + modifiers)`);let u=C(a)?a.join("/"):a;if(!u){if(s)l.length<2&&(n.endsWith("/")?n=n.slice(0,-1):r=!0);else throw Error(`Missing required param "${o}"`)}n+=u}// avoid empty path when we have multiple optional params
return n||"/"}}}(// After some profiling, the cache seems to be unnecessary because tokenizePath
// (the slowest part of adding a route) is very fast
// const tokenCache = new Map<string, Token[][]>()
function(e){let t,n;if(!e)return[[]];if("/"===e)return[[K]];if(!e.startsWith("/"))throw Error(`Invalid path "${e}"`);// if (tokenCache.has(path)) return tokenCache.get(path)!
function r(e){throw Error(`ERR (${l})/"${u}": ${e}`)}let l=0/* TokenizerState.Static */,o=0,i=[];function s(){t&&i.push(t),t=[]}// index on the path
let a=0,u="",c="";function p(){u&&(0/* TokenizerState.Static */===l?t.push({type:0/* TokenType.Static */,value:u}):1/* TokenizerState.Param */===l||2/* TokenizerState.ParamRegExp */===l||3/* TokenizerState.ParamRegExpEnd */===l?(t.length>1&&("*"===n||"+"===n)&&r(`A repeatable param (${u}) must be alone in its segment. eg: '/:ids+.`),t.push({type:1/* TokenType.Param */,value:u,regexp:c,repeatable:"*"===n||"+"===n,optional:"*"===n||"?"===n})):r("Invalid state to consume buffer"),u="")}for(;a<e.length;){if("\\"===(n=e[a++])&&2/* TokenizerState.ParamRegExp */!==l){o=l,l=4/* TokenizerState.EscapeNext */;continue}switch(l){case 0/* TokenizerState.Static */:"/"===n?(u&&p(),s()):":"===n?(p(),l=1/* TokenizerState.Param */):u+=n;break;case 4/* TokenizerState.EscapeNext */:u+=n,l=o;break;case 1/* TokenizerState.Param */:"("===n?l=2/* TokenizerState.ParamRegExp */:X.test(n)?u+=n:(p(),l=0/* TokenizerState.Static */,"*"!==n&&"?"!==n&&"+"!==n&&a--);break;case 2/* TokenizerState.ParamRegExp */:")"===n?"\\"==c[c.length-1]?c=c.slice(0,-1)+n:l=3/* TokenizerState.ParamRegExpEnd */:c+=n;break;case 3/* TokenizerState.ParamRegExpEnd */:// same as finalizing a param
p(),l=0/* TokenizerState.Static */,"*"!==n&&"?"!==n&&"+"!==n&&a--,c="";break;default:r("Unknown state")}}// tokenCache.set(path, tokens)
return 2/* TokenizerState.ParamRegExp */===l&&r(`Unfinished custom RegExp for param "${u}"`),p(),s(),i}(e.path),n),l=w(r,{record:e,parent:t,// these needs to be populated by the parent
children:[],alias:[]});return t&&!l.record.aliasOf==!t.record.aliasOf&&t.children.push(l),l}(t,i,f),s?s.alias.push(a):(// otherwise, the first record is the original and others are aliases
(u=u||a)!==a&&u.alias.push(a),c&&e.name&&!ee(a)&&o(e.name)),p.children){let e=p.children;for(let t=0;t<e.length;t++)l(e[t],a,s&&s.children[t])}// if there was no original record, then the first one was not an alias and all
// other aliases (if any) need to reference this record when adding children
s=s||a,(a.record.components&&Object.keys(a.record.components).length||a.record.name||a.record.redirect)&&function(e){let t=0;for(;t<n.length&&/**
 * Compare function that can be used with `sort` to sort an array of PathParser
 *
 * @param a - first PathParser
 * @param b - second PathParser
 * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b
 */function(e,t){let n=0,r=e.score,l=t.score;for(;n<r.length&&n<l.length;){let e=/**
 * Compares an array of numbers as used in PathParser.score and returns a
 * number. This function can be used to `sort` an array
 *
 * @param a - first array of numbers
 * @param b - second array of numbers
 * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b
 * should be sorted first
 */function(e,t){let n=0;for(;n<e.length&&n<t.length;){let r=t[n]-e[n];// only keep going if diff === 0
if(r)return r;n++}return(// if the last subsegment was Static, the shorter segments should be sorted first
// otherwise sort the longest segment first
e.length<t.length?1===e.length&&80/* PathScore.Segment */===e[0]?-1:1:e.length>t.length?1===t.length&&80/* PathScore.Segment */===t[0]?1:-1:0)}(r[n],l[n]);// do not return if both are equal
if(e)return e;n++}if(1===Math.abs(l.length-r.length)){if(q(r))return 1;if(q(l))return -1}// if a and b share the same score entries but b has more, sort b first
return l.length-r.length;// this is the ternary version
// return aScore.length < bScore.length
//   ? 1
//   : aScore.length > bScore.length
//   ? -1
//   : 0
}(e,n[t])>=0&&// Adding children with empty path should still appear before the parent
// https://github.com/vuejs/router/issues/1124
(e.record.path!==n[t].record.path||!function e(t,n){return n.children.some(n=>n===t||e(t,n))}(e,n[t]));)t++;n.splice(t,0,e),e.record.name&&!ee(e)&&r.set(e.record.name,e)}(a)}return u?()=>{// since other matchers are aliases, they should be removed by the original matcher
o(u)}:E}function o(e){if($(e)){let t=r.get(e);t&&(r.delete(e),n.splice(n.indexOf(t),1),t.children.forEach(o),t.alias.forEach(o))}else{let t=n.indexOf(e);t>-1&&(n.splice(t,1),e.record.name&&r.delete(e.record.name),e.children.forEach(o),e.alias.forEach(o))}}return t=et({strict:!1,end:!0,sensitive:!1},t),// add initial routes
e.forEach(e=>l(e)),{addRoute:l,resolve:function(e,t){let l,o,i;let s={};if("name"in e&&e.name){if(!(l=r.get(e.name)))throw H(1/* ErrorTypes.MATCHER_NOT_FOUND */,{location:e});i=l.record.name,s=w(Z(t.params,// TODO: only keep optional params coming from a parent record
l.keys.filter(e=>!e.optional).map(e=>e.name)),// #1497 this ensures better active/exact matching
e.params&&Z(e.params,l.keys.map(e=>e.name))),// throws if cannot be stringified
o=l.stringify(s)}else if("path"in e)// no need to resolve the path with the matcher as it was provided
// this also allows the user to control the encoding
o=e.path,(l=n.find(e=>e.re.test(o)))&&(// we know the matcher works because we tested the regexp
s=l.parse(o),i=l.record.name);else{if(!// match by name or path of current route
(l=t.name?r.get(t.name):n.find(e=>e.re.test(t.path))))throw H(1/* ErrorTypes.MATCHER_NOT_FOUND */,{location:e,currentLocation:t});i=l.record.name,// since we are navigating to the same location, we don't need to pick the
// params like when `name` is provided
s=w({},t.params,e.params),o=l.stringify(s)}let a=[],u=l;for(;u;)// reversed order so parents are at the beginning
a.unshift(u.record),u=u.parent;return{name:i,path:o,params:s,matched:a,meta:a.reduce((e,t)=>w(e,t.meta),{})}},removeRoute:o,getRoutes:function(){return n},getRecordMatcher:function(e){return r.get(e)}}}(e.routes,e),o=e.parseQuery||ex,i=e.stringifyQuery||eb,s=e.history,u=eS(),c=eS(),p=eS(),f=(0,_.shallowRef)(Q),d=Q;O&&e.scrollBehavior&&"scrollRestoration"in history&&(history.scrollRestoration="manual");let h=T.bind(null,e=>""+e),m=T.bind(null,e_),S=T.bind(null,ey);function k(e,t){let n;if(// const objectLocation = routerLocationAsObject(rawLocation)
// we create a copy to modify it later
t=w({},t||f.value),"string"==typeof e){let n=P(o,e,t.path),r=l.resolve({path:n.path},t),i=s.createHref(n.fullPath);// locationNormalized is always a new object
return w(n,r,{params:S(r.params),hash:ey(n.hash),redirectedFrom:void 0,href:i})}// path could be relative in object as well
if("path"in e)n=w({},e,{path:P(o,e.path,t.path).path});else{// remove any nullish param
let r=w({},e.params);for(let e in r)null==r[e]&&delete r[e];// pass encoded values to the matcher, so it can produce encoded path and fullPath
n=w({},e,{params:m(r)}),// current location params are decoded, we need to encode them in case the
// matcher merges the params
t.params=m(t.params)}let r=l.resolve(n,t),a=e.hash||"";// the matcher might have merged current location params, so
// we need to run the decoding again
r.params=h(S(r.params));let u=/**
 * Stringifies a URL object
 *
 * @param stringifyQuery
 * @param location
 */function(e,t){let n=t.query?e(t.query):"";return t.path+(n&&"?")+n+(t.hash||"")}(i,w({},e,{hash:eg(a).replace(ef,"{").replace(eh,"}").replace(ec,"^"),path:r.path})),c=s.createHref(u);return w({fullPath:u,hash:// hash
a,query:// nested objects, so we keep the query as is, meaning it can contain
// numbers at `$route.query`, but at the point, the user will have to
// use their own type anyway.
// https://github.com/vuejs/router/issues/328#issuecomment-649481567
i===eb?/**
 * Transforms a {@link LocationQueryRaw} into a {@link LocationQuery} by casting
 * numbers into strings, removing keys with an undefined value and replacing
 * undefined with null in arrays
 *
 * @param query - query object to normalize
 * @returns a normalized query object
 */function(e){let t={};for(let n in e){let r=e[n];void 0!==r&&(t[n]=C(r)?r.map(e=>null==e?null:""+e):null==r?r:""+r)}return t}(e.query):e.query||{}},r,{redirectedFrom:void 0,href:c})}function R(e){return"string"==typeof e?P(o,e,f.value.path):w({},e)}function F(e,t){if(d!==e)return H(8/* ErrorTypes.NAVIGATION_CANCELLED */,{from:t,to:e})}function N(e){let t=e.matched[e.matched.length-1];if(t&&t.redirect){let{redirect:n}=t,r="function"==typeof n?n(e):n;return"string"==typeof r&&// @ts-expect-error: force empty params when a string is passed to let
// the router parse them again
((r=r.includes("?")||r.includes("#")?r=R(r):{path:r}).params={}),w({query:e.query,hash:e.hash,// avoid transferring params if the redirect has a path
params:"path"in r?{}:e.params},r)}}function L(e,t){let n;let r=d=k(e),l=f.value,o=e.state,s=e.force,a=!0===e.replace,u=N(r);return u?L(w(R(u),{state:"object"==typeof u?w({},o,u.state):o,force:s,replace:a}),t||r):(r.redirectedFrom=t,!s&&/**
 * Checks if two RouteLocation are equal. This means that both locations are
 * pointing towards the same {@link RouteRecord} and that all `params`, `query`
 * parameters and `hash` are the same
 *
 * @param stringifyQuery - A function that takes a query object of type LocationQueryRaw and returns a string representation of it.
 * @param a - first {@link RouteLocation}
 * @param b - second {@link RouteLocation}
 */function(e,t,n){let r=t.matched.length-1,l=n.matched.length-1;return r>-1&&r===l&&A(t.matched[r],n.matched[l])&&V(t.params,n.params)&&e(t.query)===e(n.query)&&t.hash===n.hash}(i,l,r)&&(n=H(16/* ErrorTypes.NAVIGATION_DUPLICATED */,{to:r,from:l}),// trigger scroll to allow scrolling to the same anchor
es(l,l,// history.listen is with a redirect, which makes it become a push
!0,// cannot be manually navigated to
!1)),(n?Promise.resolve(n):U(r,l)).catch(e=>z(e)?z(e,2/* ErrorTypes.NAVIGATION_GUARD_REDIRECT */)?e:ei(e)// also returns the error
    :eo(e,r,l)).then(e=>{if(e){if(z(e,2/* ErrorTypes.NAVIGATION_GUARD_REDIRECT */))return L(w({replace:a},R(e.to),{state:"object"==typeof e.to?w({},o,e.to.state):o,force:s}),t||r)}else e=en(r,l,!0,a,o);return W(r,l,e),e}))}/**
     * Helper to reject and skip all navigation guards if a new navigation happened
     * @param to
     * @param from
     */function B(e,t){let n=F(e,t);return n?Promise.reject(n):Promise.resolve()}function D(e){let t=eu.values().next().value;// support Vue < 3.3
return t&&"function"==typeof t.runWithContext?t.runWithContext(e):e()}// TODO: refactor the whole before guards by internally using router.beforeEach
function U(e,t){let n;let[r,l,o]=function(e,t){let n=[],r=[],l=[],o=Math.max(t.matched.length,e.matched.length);for(let i=0;i<o;i++){let o=t.matched[i];o&&(e.matched.find(e=>A(e,o))?r.push(o):n.push(o));let s=e.matched[i];s&&!t.matched.find(e=>A(e,s))&&l.push(s)}return[n,r,l]}(e,t);// leavingRecords is already reversed
for(let l of(// all components here have been resolved once because we are leaving
n=eP(r.reverse(),"beforeRouteLeave",e,t),r))l.leaveGuards.forEach(r=>{n.push(ek(r,e,t))});let i=B.bind(null,e,t);// run the queue of per route beforeRouteLeave guards
return n.push(i),ed(n).then(()=>{for(let r of(// check global guards beforeEach
n=[],u.list()))n.push(ek(r,e,t));return n.push(i),ed(n)}).then(()=>{for(let r of(// check in components beforeRouteUpdate
n=eP(l,"beforeRouteUpdate",e,t),l))r.updateGuards.forEach(r=>{n.push(ek(r,e,t))});// run the queue of per route beforeEnter guards
return n.push(i),ed(n)}).then(()=>{for(let r of(// check the route beforeEnter
n=[],o))if(r.beforeEnter){if(C(r.beforeEnter))for(let l of r.beforeEnter)n.push(ek(l,e,t));else n.push(ek(r.beforeEnter,e,t))}// run the queue of per route beforeEnter guards
return n.push(i),ed(n)}).then(()=>(// NOTE: at this point to.matched is normalized and does not contain any () => Promise<Component>
    // clear existing enterCallbacks, these are added by extractComponentsGuards
    e.matched.forEach(e=>e.enterCallbacks={}),// check in-component beforeRouteEnter
    (n=eP(o,"beforeRouteEnter",e,t)).push(i),ed(n))).then(()=>{for(let r of(// check global guards beforeResolve
n=[],c.list()))n.push(ek(r,e,t));return n.push(i),ed(n)})// catch any navigation canceled
.catch(e=>z(e,8/* ErrorTypes.NAVIGATION_CANCELLED */)?e:Promise.reject(e))}function W(e,t,n){// navigation is confirmed, call afterGuards
// TODO: wrap with error handlers
p.list().forEach(r=>D(()=>r(e,t,n)))}/**
     * - Cleans up any navigation guards
     * - Changes the url if necessary
     * - Calls the scrollBehavior
     */function en(e,t,n,r,l){// a more recent navigation took place
let o=F(e,t);if(o)return o;// only consider as push if it's not the first navigation
let i=t===Q,a=O?history.state:{};n&&(r||i?s.replace(e.fullPath,w({scroll:i&&a&&a.scroll},l)):s.push(e.fullPath,l)),// accept current navigation
f.value=e,es(e,t,n,i),ei()}// Initialization and Errors
let er=eS(),el=eS();/**
     * Trigger errorHandlers added via onError and throws the error as well
     *
     * @param error - error to throw
     * @param to - location we were navigating to when the error happened
     * @param from - location we were navigating from when the error happened
     * @returns the error as a rejected promise
     */function eo(e,t,n){ei(e);let r=el.list();return r.length?r.forEach(r=>r(e,t,n)):console.error(e),Promise.reject(e)}function ei(e){return n||(// still not ready if an error happened
n=!e,t||(t=s.listen((e,t,n)=>{if(!ep.listening)return;// cannot be a redirect route because it was in history
let r=k(e),l=N(r);if(l){L(w(l,{replace:!0}),r).catch(E);return}d=r;let o=f.value;// TODO: should be moved to web history?
if(O){var i,u;i=j(o.fullPath,n.delta),u=M(),I.set(i,u)}U(r,o).catch(e=>z(e,12/* ErrorTypes.NAVIGATION_CANCELLED */)?e:z(e,2/* ErrorTypes.NAVIGATION_GUARD_REDIRECT */)?(// Here we could call if (info.delta) routerHistory.go(-info.delta,
    // false) but this is bug prone as we have no way to wait the
    // navigation to be finished before calling pushWithRedirect. Using
    // a setTimeout of 16ms seems to work but there is no guarantee for
    // it to work on every browser. So instead we do not restore the
    // history entry and trigger a new navigation as requested by the
    // navigation guard.
    // the error is already handled by router.push we just want to avoid
    // logging the error
    L(e.to,r).then(e=>{z(e,20/* ErrorTypes.NAVIGATION_DUPLICATED */)&&!n.delta&&n.type===a.pop&&s.go(-1,!1)}).catch(E),Promise.reject()):(n.delta&&s.go(-n.delta,!1),eo(e,r,o))).then(e=>{(e=e||en(r,o,!1))&&(n.delta&&// a new navigation has been triggered, so we do not want to revert, that will change the current history
// entry while a different route is displayed
!z(e,8/* ErrorTypes.NAVIGATION_CANCELLED */)?s.go(-n.delta,!1):n.type===a.pop&&z(e,20/* ErrorTypes.NAVIGATION_DUPLICATED */)&&// it's like a push but lacks the information of the direction
s.go(-1,!1)),W(r,o,e)}).catch(E)})),er.list().forEach(([t,n])=>e?n(e):t()),er.reset()),e}// Scroll behavior
function es(t,n,r,l){let{scrollBehavior:o}=e;if(!O||!o)return Promise.resolve();let i=!r&&function(e){let t=I.get(e);return(// consume it so it's not used again
I.delete(e),t)}(j(t.fullPath,0))||(l||!r)&&history.state&&history.state.scroll||null;return(0,g.nextTick)().then(()=>o(t,n,i)).then(e=>e&&function(e){let t;if("el"in e){let n=e.el,r="string"==typeof n&&n.startsWith("#"),l="string"==typeof n?r?document.getElementById(n.slice(1)):document.querySelector(n):n;if(!l)return;t=function(e,t){let n=document.documentElement.getBoundingClientRect(),r=e.getBoundingClientRect();return{behavior:t.behavior,left:r.left-n.left-(t.left||0),top:r.top-n.top-(t.top||0)}}(l,e)}else t=e;"scrollBehavior"in document.documentElement.style?window.scrollTo(t):window.scrollTo(null!=t.left?t.left:window.pageXOffset,null!=t.top?t.top:window.pageYOffset)}(e)).catch(e=>eo(e,t,n))}let ea=e=>s.go(e),eu=new Set,ep={currentRoute:f,listening:!0,addRoute:function(e,t){let n,r;return $(e)?(n=l.getRecordMatcher(e),r=t):r=e,l.addRoute(r,n)},removeRoute:function(e){let t=l.getRecordMatcher(e);t&&l.removeRoute(t)},hasRoute:function(e){return!!l.getRecordMatcher(e)},getRoutes:function(){return l.getRoutes().map(e=>e.record)},resolve:k,options:e,push:function(e){return L(e)},replace:function(e){return L(w(R(e),{replace:!0}))},go:ea,back:()=>ea(-1),forward:()=>ea(1),beforeEach:u.add,beforeResolve:c.add,afterEach:p.add,onError:el.add,isReady:function(){return n&&f.value!==Q?Promise.resolve():new Promise((e,t)=>{er.add([e,t])})},install(e){e.component("RouterLink",eA),e.component("RouterView",eN),e.config.globalProperties.$router=this,Object.defineProperty(e.config.globalProperties,"$route",{enumerable:!0,get:()=>(0,_.unref)(f)}),O&&// used for the initial navigation client side to avoid pushing
// multiple times when the router is used in multiple apps
!r&&f.value===Q&&(// see above
r=!0,L(s.location).catch(e=>{}));let o={};for(let e in Q)Object.defineProperty(o,e,{get:()=>f.value[e],enumerable:!0});e.provide(eT,this),e.provide(eE,(0,_.shallowReactive)(o)),e.provide(eC,f);let i=e.unmount;eu.add(e),e.unmount=function(){eu.delete(e),eu.size<1&&(// invalidate the current navigation
d=Q,t&&t(),t=null,f.value=Q,r=!1,n=!1),i()},__VUE_PROD_DEVTOOLS__&&O&&function(e,t,n){// Take over router.beforeEach and afterEach
// make sure we are not registering the devtool twice
if(t.__hasDevtools)return;t.__hasDevtools=!0;// increment to support multiple router instances
let r=eI++;!function(e,t){let n=y(),r=y().__VUE_DEVTOOLS_GLOBAL_HOOK__,l=x&&e.enableEarlyProxy;if(r&&(n.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__||!l))r.emit("devtools-plugin:setup",e,t);else{let o=l?new b(e,r):null,i=n.__VUE_DEVTOOLS_PLUGINS__=n.__VUE_DEVTOOLS_PLUGINS__||[];i.push({pluginDescriptor:e,setupFn:t,proxy:o}),o&&t(o.proxiedTarget)}}({id:"org.vuejs.router"+(r?"."+r:""),label:"Vue Router",packageName:"vue-router",homepage:"https://router.vuejs.org",logo:"https://router.vuejs.org/logo.png",componentStateTypes:["Routing"],app:e},l=>{let o;"function"!=typeof l.now&&console.warn("[Vue Router]: You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."),// display state added by the router
l.on.inspectComponent((e,n)=>{e.instanceData&&e.instanceData.state.push({type:"Routing",key:"$route",editable:!1,value:eM(t.currentRoute.value,"Current Route")})}),// mark router-link as active and display tags on router views
l.on.visitComponentTree(({treeNode:e,componentInstance:t})=>{if(t.__vrv_devtools){let n=t.__vrv_devtools;e.tags.push({label:(n.name?`${n.name.toString()}: `:"")+n.path,textColor:0,tooltip:"This component is rendered by &lt;router-view&gt;",backgroundColor:15485081})}C(t.__vrl_devtools)&&(t.__devtoolsApi=l,t.__vrl_devtools.forEach(t=>{let n=16486972,r="";t.isExactActive?(n=8702998,r="This is exactly active"):t.isActive&&(n=2450411,r="This link is active"),e.tags.push({label:t.route.path,textColor:0,tooltip:r,backgroundColor:n})}))}),(0,g.watch)(t.currentRoute,()=>{// refresh active state
u(),l.notifyComponentUpdate(),l.sendInspectorTree(a),l.sendInspectorState(a)});let i="router:navigations:"+r;l.addTimelineLayer({id:i,label:`Router${r?" "+r:""} Navigations`,color:4237508}),// const errorsLayerId = 'router:errors'
// api.addTimelineLayer({
//   id: errorsLayerId,
//   label: 'Router Errors',
//   color: 0xea5455,
// })
t.onError((e,t)=>{l.addTimelineEvent({layerId:i,event:{title:"Error during Navigation",subtitle:t.fullPath,logType:"error",time:l.now(),data:{error:e},groupId:t.meta.__navigationId}})});// attached to `meta` and used to group events
let s=0;t.beforeEach((e,t)=>{let n={guard:ej("beforeEach"),from:eM(t,"Current Location during this navigation"),to:eM(e,"Target location")};// Used to group navigations together, hide from devtools
Object.defineProperty(e.meta,"__navigationId",{value:s++}),l.addTimelineEvent({layerId:i,event:{time:l.now(),title:"Start of navigation",subtitle:e.fullPath,data:n,groupId:e.meta.__navigationId}})}),t.afterEach((e,t,n)=>{let r={guard:ej("afterEach")};n?(r.failure={_custom:{type:Error,readOnly:!0,display:n?n.message:"",tooltip:"Navigation Failure",value:n}},r.status=ej("❌")):r.status=ej("✅"),// we set here to have the right order
r.from=eM(t,"Current Location during this navigation"),r.to=eM(e,"Target location"),l.addTimelineEvent({layerId:i,event:{title:"End of navigation",subtitle:e.fullPath,time:l.now(),data:r,logType:n?"warning":"default",groupId:e.meta.__navigationId}})});/**
         * Inspector of Existing routes
         */let a="router-inspector:"+r;function u(){// the routes view isn't active
if(!o)return;let e=o,r=n.getRoutes().filter(e=>!e.parent);// reset match state to false
r.forEach(e$),e.filter&&(r=r.filter(t=>(function e(t,n){let r=String(t.re).match(eU);if(t.__vd_match=!1,!r||r.length<3)return!1;// use a regexp without $ at the end to match nested routes better
    let l=new RegExp(r[1].replace(/\$$/,""),r[2]);if(l.test(n))return(// exception case: `/`
    // mark children as matches
    t.children.forEach(t=>e(t,n)),("/"!==t.record.path||"/"===n)&&(t.__vd_match=t.re.test(n),!0));let o=t.record.path.toLowerCase(),i=ey(o);return(// also allow partial matching on the path
    !!(!n.startsWith("/")&&(i.includes(n)||o.includes(n))||i.startsWith(n)||o.startsWith(n)||t.record.name&&String(t.record.name).includes(n))||t.children.some(t=>e(t,n)))})(t,e.filter.toLowerCase()))),// mark active routes
r.forEach(e=>(function e(t,n){// no route will be active if matched is empty
    // reset the matching state
    let r=n.matched.length&&A(n.matched[n.matched.length-1],t.record);t.__vd_exactActive=t.__vd_active=r,r||(t.__vd_active=n.matched.some(e=>A(e,t.record))),t.children.forEach(t=>e(t,n))})(e,t.currentRoute.value)),e.rootNodes=r.map(eB)}l.addInspector({id:a,label:"Routes"+(r?" "+r:""),icon:"book",treeFilterPlaceholder:"Search routes"}),l.on.getInspectorTree(t=>{o=t,t.app===e&&t.inspectorId===a&&u()}),/**
         * Display information about the currently selected route record
         */l.on.getInspectorState(t=>{if(t.app===e&&t.inspectorId===a){let e=n.getRoutes(),r=e.find(e=>e.record.__vd_id===t.nodeId);r&&(t.state={options:function(e){let{record:t}=e,n=[{editable:!1,key:"path",value:t.path}];return null!=t.name&&n.push({editable:!1,key:"name",value:t.name}),n.push({editable:!1,key:"regexp",value:e.re}),e.keys.length&&n.push({editable:!1,key:"keys",value:{_custom:{type:null,readOnly:!0,display:e.keys.map(e=>`${e.name}${e.optional?e.repeatable?"*":"?":e.repeatable?"+":""}`).join(" "),tooltip:"Param keys",value:e.keys}}}),null!=t.redirect&&n.push({editable:!1,key:"redirect",value:t.redirect}),e.alias.length&&n.push({editable:!1,key:"aliases",value:e.alias.map(e=>e.record.path)}),Object.keys(e.record.meta).length&&n.push({editable:!1,key:"meta",value:e.record.meta}),n.push({key:"score",editable:!1,value:{_custom:{type:null,readOnly:!0,display:e.score.map(e=>e.join(", ")).join(" | "),tooltip:"Score used to sort routes",value:e.score}}}),n}(r)})}}),l.sendInspectorTree(a),l.sendInspectorState(a)})}(e,this,l)}};// TODO: type this as NavigationGuardReturn or similar instead of any
function ed(e){return e.reduce((e,t)=>e.then(()=>D(t)),Promise.resolve())}return ep}({history:/**
 * Creates an HTML5 history. Most common history for single page applications.
 *
 * @param base -
 */function(e){e=// Generic utils
/**
 * Normalizes a base by removing any trailing slash and reading the base tag if
 * present.
 *
 * @param base - base to normalize
 */function(e){if(!e){if(O){// respect <base> tag
let t=document.querySelector("base");// strip full URL origin
e=(e=t&&t.getAttribute("href")||"/").replace(/^\w+:\/\/[^\/]+/,"")}else e="/"}// remove the trailing slash so all other method can just do `base + fullPath`
// to build an href
return"/"!==e[0]&&"#"!==e[0]&&(e="/"+e),k(e)}(e);let t=function(e){let{history:t,location:n}=window,r={value:D(e,n)},l={value:t.state};function o(r,o,i){/**
         * if a base tag is provided, and we are on a normal domain, we have to
         * respect the provided `base` attribute because pushState() will use it and
         * potentially erase anything before the `#` like at
         * https://github.com/vuejs/router/issues/685 where a base of
         * `/folder/#` but a base of `/` would erase the `/folder/` section. If
         * there is no host, the `<base>` tag makes no sense and if there isn't a
         * base tag we can just use everything after the `#`.
         */let s=e.indexOf("#"),a=s>-1?(n.host&&document.querySelector("base")?e:e.slice(s))+r:B()+e+r;try{// BROWSER QUIRK
// NOTE: Safari throws a SecurityError when calling this function 100 times in 30 seconds
t[i?"replaceState":"pushState"](o,"",a),l.value=o}catch(e){console.error(e),// Force the navigation, this also resets the call count
n[i?"replace":"assign"](a)}}return l.value||o(r.value,{back:null,current:r.value,forward:null,// the length is off by one, we need to decrease it
position:t.length-1,replaced:!0,// don't add a scroll as the user may have an anchor, and we want
// scrollBehavior to be triggered without a saved position
scroll:null},!0),{location:r,state:l,push:function(e,n){// Add to current entry the information of where we are going
// as well as saving the current position
let i=w({},// history.replaceState
// https://github.com/vuejs/router/issues/366
l.value,t.state,{forward:e,scroll:M()});o(i.current,i,!0);let s=w({},U(r.value,e,null),{position:i.position+1},n);o(e,s,!1),r.value=e},replace:function(e,n){let i=w({},t.state,U(l.value.back,e,l.value.forward,!0),n,{position:l.value.position});o(e,i,!0),r.value=e}}}(e),n=function(e,t,n,r){let l=[],o=[],i=null,s=({state:o})=>{let s=D(e,location),c=n.value,p=t.value,f=0;if(o){// ignore the popstate and reset the pauseState
if(n.value=s,t.value=o,i&&i===c){i=null;return}f=p?o.position-p.position:0}else r(s);// console.log({ deltaFromCurrent })
// Here we could also revert the navigation by calling history.go(-delta)
// this listener will have to be adapted to not trigger again and to wait for the url
// to be updated before triggering the listeners. Some kind of validation function would also
// need to be passed to the listeners so the navigation can be accepted
// call all listeners
l.forEach(e=>{e(n.value,c,{delta:f,type:a.pop,direction:f?f>0?u.forward:u.back:u.unknown})})};function c(){let{history:e}=window;e.state&&e.replaceState(w({},e.state,{scroll:M()}),"")}return(// set up the listeners and prepare teardown callbacks
window.addEventListener("popstate",s),// TODO: could we use 'pagehide' or 'visibilitychange' instead?
// https://developer.chrome.com/blog/page-lifecycle-api/
window.addEventListener("beforeunload",c,{passive:!0}),{pauseListeners:function(){i=n.value},listen:function(e){// set up the listener and prepare teardown callbacks
l.push(e);let t=()=>{let t=l.indexOf(e);t>-1&&l.splice(t,1)};return o.push(t),t},destroy:function(){for(let e of o)e();o=[],window.removeEventListener("popstate",s),window.removeEventListener("beforeunload",c)}})}(e,t.state,t.location,t.replace),r=w({// it's overridden right after
location:"",base:e,go:function(e,t=!0){t||n.pauseListeners(),history.go(e)},createHref:L.bind(null,e)},t,n);return Object.defineProperty(r,"location",{enumerable:!0,get:()=>t.location.value}),Object.defineProperty(r,"state",{enumerable:!0,get:()=>t.state.value}),r}(),routes:[{path:"/",component:eQ},{path:"/about",component:()=>h("kgbrZ")}]});(0,m.createApp)(e).use(eW).mount("#app");//# sourceMappingURL=index.524d4a6a.js.map

//# sourceMappingURL=index.524d4a6a.js.map
